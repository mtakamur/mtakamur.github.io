<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>πの実</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="個人的な備忘録です。主に初心者の方の疑問解消に少しでも役立てれば幸いです。"
    />
    <meta
      name="keywords"
      content="C,C++,C#,Kotlin,ROOT,CERN,Android,R,初心者,入門,文法"
    />
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/js/highlight/styles/darcula.css" />
    <script src="/js/highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script
    ><![endif]-->
  </head>

  <script type="text/javascript" src="/js/embed-date.js"></script>

  <body onload="onloadEmbed()">
    <div id="menubar">
      <ul>
        <li><a href="/index.html">Home</a></li>
        <li>
          <a>Contents <span class="caret"></span></a>
          <div>
            <ul id="contents">
              <script
                type="text/javascript"
                src="/js/embed-content-list.js"
              ></script>
            </ul>
          </div>
        </li>
      </ul>
    </div>
    <div id="container">
      <header>
        <div id="logo" style="text-align: center">
          <a href="/index.html">
            <img src="/images/logo.png" style="width: 150px; height: 46px"
          /></a>
        </div>
      </header>

      <div id="date" style="text-align: right">
        <p>更新日: 2021/9/12</p>
      </div>

      <h1 style="text-align: center">まとめ</h1>
      <ul>
        <li>
          toList, toSet, toMap
          などの、コレクションの変換メソッドで得られるのは"浅いコピー" (Shallow
          copy)
        </li>
        <li>
          コレクションそのものは変換元とは別インスタンスなるが、プリミティブ型以外の要素は参照のコピーなので、目的に合ったコピーになっているか注意が必要
        </li>
        <li>
          <b
            >data classのcopy()メソッドによるコピーも、実際は shallow
            copy。プリミティブ型以外のプロパティについては元のインスタンスと同じ参照を持つ</b
          >
        </li>
        <li>
          Kotlin組み込みの実装だけによってdeep
          copyを作ることは現状できない。クラスごとにdeep
          copy用のメソッドを自力で実装するのが単純。
        </li>
      </ul>

      <h2>インスタンスのコピー</h2>
      <p>
        toList,
        toSetなど、コレクションを変換、コピーすることができるメソッドがKotlinには用意されています。この時、コレクションの要素も
        deep copy されると思い込んではまったお話。
      </p>

      <p>
        値やインスタンスの集合であるコレクション(List, Set,
        Mapなど)を丸ごとコピーしたい場合は、下記のようにtoList, toSet,
        toMapなど、目的の型への変換メソッドを使うことでコピーが行えます。
        to~はコレクションの変換メソッドとして紹介されることが多いですが、<b>変換元の型と同じ型への変換メソッドを使うと、中身が同じだけれども別インスタンスとしてのコレクション(コピー)を得ることができます</b>。
        ただし、プリミティブ型以外の要素は、 shallow copy
        が作られるだけで、参照先は変わりません。
      </p>

      <p>
        下記を例にとってみます。 Person クラスを要素に持つ List を、 toList()
        メソッドによってコピーしています。生成されたコピーに対して、一つ目の要素の値を書き換えてみます。
      </p>
      <pre>
      <code>
        data class Person(
          var name: String
        )

        fun shallowCopy() {
          val family = listOf(
              Person("a"),
              Person("b")
          )
          val shallowCopiedFamily = family.toList()
      
          // 一人目の名前を変えちゃう
          shallowCopiedFamily.first().name = "c"
      
          println("family = $family")
          println("copiedFamily = $shallowCopiedFamily")
         }
      </code>
      </pre>

      <p>
        要素を書き換えた後のそれぞれの List
        を出力してみると下記のようになります。
      </p>

      <pre>
        <code>
          family = [Person(name=c), Person(name=b)]
          copiedFamily = [Person(name=c), Person(name=b)]
        </code>
      </pre>

      <p>
        コピー先だけに変更を加えたつもりが、コピー元のfamilyの要素まで変更されています。
      </p>

      <img
        style="margin: auto; display: block"
        src="/kotlin/struggled/images/shallow_copy.png"
      />

      <p>
        プリミティブ型以外の要素を持つコレクションをディープコピーしたい場合は、下記のように一工夫必要となります。
      </p>
      <pre>
        <code>
          fun deepCopy() {
            val family = listOf(
                Person("a"),
                Person("b")
            )
            val deepCopiedFamily = family.map { member -> member.copy() }
        
            // 一人目の名前を変えちゃう
            deepCopiedFamily.first().name = "c"
        
            println("family = $family")
            println("copiedFamily = $deepCopiedFamily")
            }
        </code>
      </pre>
      <pre>
        <code>
          family = [Person(name=a), Person(name=b)]
          copiedFamily = [Person(name=c), Person(name=b)]
        </code>
      </pre>

      <p>
        一例でしかありませんが、この例ではmap()メソッドによって要素を逐一コピーしたものを新しく生成されるコレクションの要素に与えています。
        インスタンスに対してcopy()メソッドを実行すると、そのインスタンスのdeep
        copyが返されます。これを新しいコレクションの要素とすれば、各要素のdeep
        copyで構成されたコレクションが得られます。
      </p>

      <h2>プリミティブ型は例外</h2>
      <p>
        プリミティブ型については、to~によるコピーで別の値としてのコピーが作成されます。(そもそもプリミティブ型に対してcopy()メソッドは定義されていない)
      </p>
      <pre>
        <code>
          fun primitiveCopy() {
            val list = listOf(0, 1)
            val copiedList = list.toMutableList()
        
            // コピーしたリストの要素をいじってみる
            copiedList[0] = 2
        
            println("list = $list")
            println("copiedList = $copiedList")
        }
        </code>
      </pre>
      <pre>
        <code>
          list = [0, 1]
          copiedList = [2, 1]
        </code>
      </pre>

      <p>
        試しにやってみると、単にtoList()によって(要素をいじりたいので実際はtoMutableList()によって)作られたコピーの要素をいじってみても、元の要素に変更はないことがわかります。
      </p>

      <h2>copyメソッドでも shallow copy が作られる(2021/9/12 追記)</h2>
      <p>
        data class の　copy() メソッドに関して訂正です。 deep copy が欲しければ
        data class の copy()
        メソッドを使えばよいと上で述べましたが、実際に生成されるのは shallow
        copy のため、状況によっては不適切です。
      </p>

      <p>
        "状況によっては"というのも、コピーしたい data class
        のプロパティがプリミティブ型のみであれば、実際は deep copy
        の生成とみなせますので問題は起こらないはずです。問題が起こりうるのは、下記のように<b>インスタンスをプロパティとして保持している場合</b>です。
      </p>
      <pre>
        <code>
        data class Container(val content: Content)
        data class Content(var id: Int)

          fun instanceProperty() {
            val content = Content(0)
            val container = Container(content)
            val copiedContainer = container.copy()
        
            copiedContainer.content.id = 1
        
            println("content in container = $container")
            println("content in copiedContainer = $copiedContainer")
        }
        </code>
      </pre>
      <p>
        実行結果は下記のようになり、 Container クラスのプロパティである content
        インスタンスは元の参照と同じものを持っているため、コピー先への変更がコピー元が保持している
        content にまで及んでいることがわかります。
      </p>
      <pre>
        <code>
        content in container = Container(content=Content(id=1))
        content in copiedContainer = Container(content=Content(id=1))
        </code>
      </pre>

      <p>
        こういったケースで deep copy が必要になる場合は Container クラスに自力で
        copy メソッドを実装して、プロパティのインスタンスも copy
        によってコピーするのが単純でしょうか…。
      </p>
      <pre>
        <code>
          data class Container(val content: Content) {
              fun copy() = Container(content.copy()) // 手動コピー
          }

          data class Content(var id: Int)
        </code>
      </pre>
      <p>
        上記のコードで一応の目的は果たせることになりますが、拡張性もメンテナンス性も最悪です。
        Container クラスを拡張した場合は忘れずに独自実装の copy()
        メソッドも修正する必要があります(が、質の悪いことに修正を忘れてもコンパイルは通ってしまいます)。
      </p>

      <p>
        調べてみると、
        <a href="https://github.com/bennyhuo/KotlinDeepCopy"
          >deep copy を生成するためのライブラリ</a
        >も公開されているようです。
      </p>

      <p>
        コピーなんて単純だと思っていましたが、目的にあったコピーは意外と難しいものでした…。スマートなアイディアをお持ちの方、ぜひ<a
          href="mailto:mtakamur.gio@gmail.com"
          >筆者</a
        >に教えてください
      </p>
    </div>
  </body>
</html>
