[{"uri":"https://mtakamur.github.io/dart/setup_environment/","title":"Dart開発環境のセットアップ","tags":[],"description":"","content":"IntelliJ ideaによる Dart の開発環境の設定方法。\nコードエディタとして IntelliJ idea を用いた場合の Dart の開発環境の構築方法を解説します。 本解説では IntelliJ idea がすでにインストールされていることを前提としますので、インストールがまだお済でない方は公式ページより IntelliJ idea をインストールしておいてください。 インストールするのはフリーで利用できる Community edition で問題ありません。\nDart プラグインの導入 IntelliJ idea のインストールが完了したら、まずは Dart での開発をサポートするプラグインを導入します。Plugins から Dart のプラグインを探してインストールボタンを押すだけです。 Dart SDK のダウンロードと導入 Dart 用の開発環境を取得して設定します。公式での案内によれば、SDK の取得方法はいろいろとあるようです。 今回は簡単に、SDK 一式を zip として取得する方法を用います。\nzip archive のリンクから、適当な zip archive をダウンロードします。 特に理由がなければ Stable channel にリストアップされているものから選ぶのが無難そうです。\nダウンロードした zip ファイルを解凍し、ホームディレクトリなどの適当な場所に配置します。 zip を解凍すると、dart-sdk というフォルダが生成されますが、必要があれば任意の名前に変更しても問題ありません(本説明では、生成されたフォルダ名は dart-sdk として進めます)。 dart-sdk を任意の場所に配置すれば、開発環境のセットアップは完了です。\nHello World idea のスタートページから新規の Dart プロジェクトを開始します。 プロジェクトを始めるには dart-sdk のパスを指定する必要があるので、上記でインストールした dart-sdk のパスを入力します。 プロジェクト名を決め、next で次に進んでゆくと、おなじみ Hello World のサンプルコードによるプロジェクトが生成されます。 idea の画面から main 関数を実行すれば、めでたく Hello World が表示されます。\n以上で開発環境のセットアップは完了です。\n"},{"uri":"https://mtakamur.github.io/dart/","title":"Dart","tags":[],"description":"","content":"Google 製の開発言語。 Web アプリケーション開発をはじめ、Flutter によるマルチプラットフォームアプリの開発にも使われます。\nGoogle による公式ページはこちら\n Dart開発環境のセットアップ  IntelliJ ideaによる Dart の開発環境の設定方法。\n 関数の基礎  プログラムを構成する基礎である関数(メソッド)。 Dart 言語での書き方を学びます。\n 変数の宣言  整数や文字列などの情報を保持しておくための箱「変数」。 ここでは Dart 言語における変数の宣言方法について学びます。\n"},{"uri":"https://mtakamur.github.io/dart/basis_on_function/","title":"関数の基礎","tags":[],"description":"","content":"プログラムを構成する基礎である関数(メソッド)。 Dart 言語での書き方を学びます。\nmain 関数 多くのプログラム言語と同様、Dart によるプログラムも main 関数という特別な名前の関数がプログラムの始点となります。 同名の関数は複数定義することができませんので、プログラムの始点となるmain関数は常にただ一つに決まります。\nvoid main() { print(\u0026#34;Hello World!\u0026#34;); } 上記がおなじみ Hello World のサンプルコードです。 関数名の前に特定の型を指定することによって、その関数の戻り値の型を指定することができます。\n上記の例ではmainメソッドは何も返さない void 型として定義されています。 main関数は void 型であるため、main関数内にはreturnが無いことがわかります。\nmain関数は必ずしも void 型である必要はなく、特に意味はないですが下記のように int 型の関数として定義することも許されています。 下記を実行してみるとわかりますが、main 関数の return の値として何を返してもプログラムの終了コードは 0 になります。 プログラムが正常終了した場合にはmain関数で 0 を返すという実装は C 言語などによく見られるものですが、Dart においては main 関数の戻り値はプログラムの終了コードを意味しません。\nint main() { print(\u0026#34;Hello World!\u0026#34;); return 0; } 関数の戻り値 サンプルを下記のように書き換えてみます。 sayHelloメソッドで返されたString型の object をmainメソッド内で表示するようになっています。 関数の戻りの型についてはすでに登場済みですが、関数名の前に特定の型を明示することによってその関数が返す object の型を制限することができます。\nvoid main() { print(sayHello()); } String sayHello() { return \u0026#34;Hello World!\u0026#34;; } Dart では関数の戻り値を動的(dynamic)に決めることが許されています。 動的な戻り値を返す関数は、型の指定を省略することで実現されます。 下記の例では、sayHelloメソッドからString型の制約が外されていることがわかります。 プログラム全体の動作としてはこれまでと何ら変わりはありませんが、sayHelloメソッドからどんな型の object が返されるかをmain関数は知りません。 sayHelloメソッドは int など、どんな型の object を返しても構いませんが、逆に main メソッドは何が返されても動作に問題がないように実装される必要があります。 もし関数の戻り値を静的(static)に決定することができるのであれば、型を明示するのが良いです。 dynamic なメソッドとして定義すると、戻り値の型についてメソッドの利用者側に無用な考慮を要求することになってしまうからです。\n戻り値の型の省略は、Kotlin などの言語にみられる型の推論とは全く異なることに注意する必要があります。 型推論される言語では戻り値の型が省略されたsayHelloメソッドは推論により String 型のメソッドとして扱われますが、Dart では dynamic なメソッド(何の型が返されるか未定)なメソッドとして扱われます。\nvoid main() { print(sayHello()); } sayHello() { var message = \u0026#34;Hello World!\u0026#34;; return message; } "},{"uri":"https://mtakamur.github.io/dart/variable_declaration/","title":"変数の宣言","tags":[],"description":"","content":"整数や文字列などの情報を保持しておくための箱「変数」。 ここでは Dart 言語における変数の宣言方法について学びます。\n変数の宣言 基本的な変数の宣言は下記のように行います。 下記は文字列を格納するためのString型の変数をmessageという名前で宣言し、その変数の中身を \u0026ldquo;Hello World!\u0026rdquo; にする書き方です。 変数の宣言の仕方はシンプルで、「変数の型 + 変数の名前 + その中身」によって行えます。\nString message = \u0026#34;Hello World!\u0026#34;; // (1) 当然、変数messageは文字列を格納するための変数ですので、下記のように無理に整数を代入しようとするとエラーになります。 変数の型は、代入しようとしている値の型に応じて適切なものを選択する必要があります。\nString message = 1; // 型の不整合によるエラー 変数の型推論 ところで(1)の変数宣言では、= の右辺を見れば、変数は明らかに String 型ですので、宣言の先頭でわざわざ String 型を宣言するのは無駄があるように思います。 そこで型推論の登場です。 Dart ではvarとして変数定義することで、値から型を推測して適当な型をあてはめてくれます。 例えば(1)と等価な宣言として、以下のような記述が可能です。\nvar message = \u0026#34;Hello World!\u0026#34;; // (2) 関数の戻り値の型を省略すると動的(dynamic)な戻り値として扱われるのに対して、varによる変数定義では型を推論して静的(static)に決定します。 従って、(2)によって決められる型は Object 型ではなく、まぎれもなく String 型であることには注意してください。\ndynamic な変数が必要な場合には以下の方法で宣言することができます。\nObject message = \u0026#34;Hello World!; もしくは\ndynamic message = \u0026#34;Hello World!\u0026#34;; 変数の初期化と null safety 突然ですが、下記の宣言による変数には何が代入されているでしょうか?\nint number; // (3) 答えは開発環境で null safety が有効かどうかによって異なります。 null safety が有効な場合には、(3)の定義は文法違反でそもそもエラーとなります。 一方、null safety が無効な場合には number は null になります。 null safety が有効かどうかは利用している Dart SDK のバージョンによって異なります。 Dart 2.12 よりも新しバージョンの Dart SDK を利用している場合には null safety が有効になっています(dart-sdk のディレクトリ内にあるversionというファイルに Dart SDK のバージョンが記載されています)。\nnull safety が有効な場合、いかなる変数も null になることが基本的にできません。 null 状態を許容しないことにより、ランタイムでの null pointer exception を回避するようになっています。 そのため、null safety が有効な場合には変数の宣言と同時に特定の値で初期化する必要があります。 例えば、int 型変数の初期化では以下のようにすると、あらかじめ 0 が代入された(0 で初期化された)変数を宣言することができます。\nint number = 0; null safety が有効な場合に null が必要な場合には、その変数が null になれること(nullable であること)を明示的に宣言する必要があり、下記のように宣言します。\nint? number; int? number = null; // 上記と等価な宣言 Dart では nullable な変数を宣言するために、変数の型に ? をつけます。 そうすることで、宣言された変数に null を代入できるようになるため、変数の初期値を省略した場合には null が代入されるようになります。\nnull safety が有効でない場合にはすべての変数が nullable になりますので、初期値を省略した場合は変数の中身は null となります。\nメソッドやその内部のスコープのみで使われるローカル変数については上記のルールはそのままあてはまりません。 ローカル変数はそのスコープ内のどこかで初期化されればよいため、たとえ null safety が有効であったとしても宣言と同時に初期化を行う必要はありません。\n遅延初期化 変数宣言時に初期値を決めることができない場合、ひとまず変数を null で初期化しておいて、時が来たら正しい値を代入するという方法があります。 アイディアとしては良いですが、この方法だとせっかくの null safety の性質を上手に活かせていません。 なぜなら、この変数における null は、変数がまだ初期化されていないという意味しか持っておらず、本質的に null を許容する必要はない(一度初期化された後は再び null になることはない)からです。 null safety が実現されている言語では、必要以上に変数を nullable にするのはランタイムの安全性に欠くので、できればそのような変数は non null な変数として定義できるとよいです。 そこで役に立つのが「遅延初期化」の仕組みです。\n変数の遅延初期化を用いると、変数の宣言時の初期化を保留することができ、かつ変数を non null に保つことができます。 下記は変数descriptionを遅延初期化によって宣言している例です。 変数の型の宣言の前に、lateをつけることでその変数が遅延初期化されることを宣言することができます。 この変数はトップレベルの変数として定義されていますが、変数の宣言時には値を初期化せず、のちに実行されるmain関数内で値を代入することによって変数を初期化しています。 もちろん、遅延初期化を宣言している変数を初期化しないまま参照するとランタイムエラーが発生しますので、忘れずに適切なタイミングで変数を初期化する必要があります。 こうすることで、変数自体は non null を維持したま、初期化のタイミングを宣言時以外に遅延することができるようになります。\nlate String description; void main() { description = \u0026#39;Feijoada!\u0026#39;; print(description); } 遅延初期化は、上記で紹介した以外にもう一つ用途があります。 下記のように、変数を遅延初期化するのは先ほどと同じですが、初期化を関数によって行うよう指定されています。 この宣言では、変数temperatureが初めて参照されたタイミングで、メソッドreadThermometerが実行されて値が初期化されます。\nlate String temperature = readThermometer(); // Lazily initialized. 一見、あえて初期化を遅延させる意図がわからないかもしれませんが、変数temperatureが必ずしも使われるとは限らない、かつreadThermometerが非常に時間のかかる処理である場合にはパフォーマンス面で有利に働く場合があります。\n遅延せずに初期化をする場合、変数temperatureが実際に利用されるかどうかにかかわらず宣言時に値が初期化されます。 実際に利用されることがなければ、この変数の初期化処理は必要ないため、せっかくの初期化処理が無駄になってしまいます。 必ずしも利用されるとは限らない変数については、初めての参照タイミングで初期化処理を実行するようにすればこのような無駄は省くことができます。 この効果は、初期化が長時間処理であればあるほど大きくなります。\nfinal 定数と const 定数 コードの中で一度定義したらその値を二度と変更する必要がない場合があります。 その場合は、final もしくは const 修飾子によって変数を定数化することをお勧めします。 final もしくは const が付与された変数は、初期化時に与えられた値で固定され、その後の変更ができなくなります。 一見自由さを捨てているだけに思えますが、これは不用意な変更から変数を守る効果があります。 仮に間違って final や const 修飾されている値を変更しようとすると、コンパイルエラーが発生するため、誤った変更に起因するバグをあらかじめ防ぐことができます。 できる必要のないことはできないようにすることが、バグの少ない安全なコードを書く上で大切です。\nfinal と const の使い分けですが、コンパイル時に値を決定できる場合は const, ランタイムで値を初期化する必要がある場合は final を用いるとよいと思います。\n例えば、光速や円周率などの値は宇宙のどこでも同じはずですので、初期化をランタイムで行う必要はありません。 このような値は、決して変わることのない定数としてコンパイル時に静的に確定することができますので、以下のように cosnt 修飾子によって定義するのが良いでしょう。\nconst c = 1; // Speed of light. 一方で、final 修飾子の使いどころは下記のような場面でしょうか。 getNumberによって得られる値で変数を初期化しています。 以下の例では、cosnt によって値を初期化しようとするとエラーになります。 getNumberが定数を返しているので以下の例では問題ないように見えますが、getNumberによって値が初期化されるのはあくまでgetNumberが実行されるタイミングです。 そのため、cosntNumberの値はコンパイル時に静的に決まっているわけではありません。\nvoid main() { final finalNumber = getNumber(); const constNumber = getNumber(); // Error } int getNumber() { return 0; } "},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_1_limit_mutability/","title":"Item 1: Limit mutability(やたらと変更可能にしない)","tags":[],"description":"","content":"更新日: 2021/12/11\nまとめ  ちょっと詳しく インスタンスの状態を表すために変数を使うことはよくあるでしょう。 Kotlin では val と var によって変数定義を行えます。 val で定義された物は一度値が代入されるともう変更できない(immutable な)変数となり、一方 var によって定義された変数は何度でも値を変更できます(mutable)。\nこれだけ見ると何でもかんでも var にしておいて、必要な時に自由に書き換えられた方が便利に見えます。 ただし、テーマである\u0026quot;安全性\u0026quot;の観点から見ると、 var を用いることによるデメリットも見えてきます。\n コードの理解とデバッグが難しくなります  var 変数はコードの実行により変更され得るポイントとなるので、その状態遷移を追いかけることは難しくなります   コードの意味の推測が難しくなります  immutable な値であれば、コードの中で変更されることのない状態となるので意味が明らかです mutable な値は、いつ、何に、どんな理由で書き換えられるのかまで理解する必要が出てくるので、状態を追いかけるのが非常に難しくなります   正しく排他処理を実装する必要があります  色々なスレッドから値が変更され得るような状況では、同時に値を書き換えられないような実装(排他制御)が必要になります もちろん、immutable な変数ではそんなこと考える必要ありません。   状態の数だけ必要なテストが増えます  値が変更されるということは、変更されるパターンの数だけ必要なテストが増加することを意味します 一般に必要なテストの量は、状態の数に対して指数関数的に増加してゆきます。変更可能な箇所は少ないほうが良いでしょう   状態変化の通知が必要になる場合があります  ある一つの mutable 変数を複数のクラスが参照しているような状況では、\u0026ldquo;誰かが値を書き換えた\u0026quot;ということを他のクラスが知る必要がある場合があります    もちろん、全ての mutable な値がダメなわけではありません。 必要に応じて、正しく賢く mutable な値を使いましょう。\nKotlin の優れているところは、immutable で良い場合には簡単にそれが実現できるところです。 valにするだけ。\nLimiting mutability in Kotlin(変更可能箇所を減らす) Kotlin では、mutability、すなわち変更可能性を制限する仕組みが下記のようにいくつか用意されています。\n valによる変数宣言 読み取り専用コレクション データクラスの copy()メソッド  これらについてもうちょっと詳しく見て行きます。\nRead-only properties val(valで定義される読み取り専用変数) すでに何度か登場していますが、Kotlin ではvalによって変数宣言することで、読み取り専用の変数を作ることができます。 ただちょっと注意しなければならないのは、valで宣言したからと言って必ずしも不変であったり、Java などでいう final を意味するわけではないということです。 例えば、後ほど登場しますが、mutable なコレクションをvalで宣言しても、コレクションの要素の変更は問題なく行えてしまいます。\nval list = mutableListOf(1, 2, 3) // Mutable = 要素の変更が可能なコレクション list.add(4) // 問題なし 上の例では、valで宣言したにもかかわらず要素の変更が行えています。これは、valが意味するのは参照先が不変ということだからです。 val listが表しているのは、どこのコレクションかという情報だけなので、参照先のコレクションにいくら変更が加えられたとしてもval listとしては知ったことではありません。 したがって、valによる変数宣言で禁止されるのは下記のような変更です。\nval list = mutableListOf(1, 2, 3) list = mutableListOf(4, 5, 6) // エラー！ 上の例では、val listが指し示す先を、4, 5, 6 を要素とするまるっきり別のコレクションに変更しようとしているためエラーになります。\nここで紹介したルールを用いると、カスタム getter() もval変数として以下のような書き方ができることになります。\nvar firstName = \u0026#34;Alice\u0026#34; var familyName = \u0026#34;Cern\u0026#34; val fullName get() = \u0026#34;$firstName$familyName\u0026#34; fum main() { println(fullName) // Alice Cern  firstName = Atlas // firstNameはmutableな変数なので書き換えてもよい  println(fullName) // Atlas Cern } fullNameはval変数なはずなのに中身が変わっていますね。 これは、fullName(のカスタム getter)はあくまでfirstNameとfamilyNameから値を計算するということしか定義されていないので、firstNameやfamilyNameの中身がどう変更されようが気にしないということになります。\nこの動作からもう一つわかることとして、カスタム getter は呼び出されるたびに参照先の値を取得して都度計算して値を出力するということです。 便利だからと言って、あまりに重い計算をカスタム getter に定義してしまうと、単に変数を読んでいるだけに見えるのに非常に反応が遅いということも起こり得ます。\nというわけで、Kotlin におけるvalプロパティは、不変である(=final である)ことを常には意味しないので注意が必要です。\nSmart cast(スマートキャスト -null じゃないのはもう知ってるね？-) valの性質から、Kotlin では smart cast という仕組みが用意されています。 ここまでで触れられていませんが、Kotlin では基本的に変数は null にはなりません。 どうしても変数の状態として null が必要な場合には、?によって明示的にそれを示す必要があります。\nval name : String? = null // これは問題なし val name : String = null // nullかもって言っていないのでこれはダメ 上記のように、null かも?という変数には、その型に?を加えます。 Kotlin では、null かもしれないクラス(?付)と絶対に null ではないクラスは別々の型と考えます。 null は便利かつ厄介な代物で、変数が null かも?(= nullable)な場合には、その取扱いはかなり気を使う必要があります(一般に null な値に対して演算はできませんで、何かしらの演算を試みた段階でいわゆる\u0026quot;ぬるぽ(NullPointerException)\u0026ldquo;が発生してプログラムが継続できなくなります)。\nnullable な値を扱うときは、多くの場合例外的な処理が必要となるので、null かどうかを都度チェックする必要があります。これが面倒くさいし、コードも汚くなるのであまりやりたくありません。 そこで、前置きが長くなりましたが、Kotlin では Smart cast という仕組みがあります。 簡単に表現すると、一度 null ではないと分かったval変数は、それ以降 non-null な値として扱える仕組みです。\nval name: String = \u0026#34;Alice\u0026#34; val age : Int? = 0 fun main() { if (age != null){ println(\u0026#34;Name = $name, age = $age\u0026#34;) ... val nextAge = age + 1 // 足し算なんかして大丈夫?  println(\u0026#34;Name = $name, age = $age\u0026#34;) } } if 節の中身だけ読むと怖いことをやっていますね。 null かもしれない値に対する足し算です。 万が一val ageが null だったら終わりです。 でもこの足し算が実行されている以上は絶対にそんなことはありません。if 節を実行する条件として、val ageが null でないことを課しているからです。 したがって、人間が読めばすぐにわかることですが、if 節の中でval ageが null ではあり得ないので、件の足し算は確実に安全に行えます。\n一方、先ほどの例とほとんど同じに見える次の例では、例の足し算は絶対に確実に安全といえるでしょうか?\nval name: String = \u0026#34;Alice\u0026#34; var age : Int? = 0 fun main() { if (age != null){ println(\u0026#34;Name = $anme, age = $age\u0026#34;) ... val nextAge = age + 1 // 足し算なんかして大丈夫...じゃないこともある  println(\u0026#34;Name = $name, age = $age\u0026#34;) } } これは安全とは言い切れません。なぜならvar ageは変更されうるからです。もし...の部分の処理でvar ageが null に変更されていた場合は、この足し算はやってはいけません。\nこれらの例からわかるように、 Smart cast はval変数は変更されないという前提の下での仕組みです。 nullable なvar変数に対しては Smart cast は機能しません(もちろんカスタム getter を備 f えた変数に対しても機能しない)。\n簡単のために上記のような例を出しましたが、実際のコーディングで Smart cast の恩恵を受けるのは、変数をメソッドにパラメータとして与える場面が多いかと思います。 もしも Smart cast がないと、呼び出すメソッドが non-null なパラメータしか受け付けない場合には、呼び出しのたびに non-null な変数にキャストしてから渡すという、本質的な処理ではないコードを書く必要が出てきます。 Smart cast があるおかげで、コードをきれいに保つことができるわけです。\nちなみに Smart cast という名前ですが、一度 null でないことを確認した以降は?がとれた(non-null な)型とみなす、ある種の型変換を意味しています。\nSeparation between mutable and read-only collections(変更可能なコレクションと不可能なコレクション) Kotlin では、要素の集合を上手に扱う手段としてコレクションが登場しています。 概念としては他言語での配列と同じです。\nすでにこれまでの例で登場していますが、コレクション(list, set, map)にも mutable なものと immutable なものが別々に用意されています(相互の変換は一応可能)。 Kotlin のコレクションは immutable なものをベースにしており、mutable なコレクションがそれを継承して setter を実装しているイメージです。\nKotlin でコレクションを扱うとき、やってはいけないことがあります。 それは immutable -\u0026gt; mutable (不変コレクションからコレクションへの)ダウンキャストです。\n 無理に書き換えると、そもそも immutable にした意味がない。チームで開発しているような状況では、\u0026ldquo;このコレクションは immutable なはず\u0026quot;という前提が崩れるので、思わぬバグを生む原因になる。 mutable とみなされても、実際に書き換えが行えるかどうかはプラットフォームの実装による(後述)  2 つめの理由についてもうちょっと詳しく説明します。例えば下記のコード例では実行結果はプラットフォームに依存します。\nval list = listOf(1, 2, 3) if (list is MutableList){ list.add(4) // ここでエラーになるかどうかはプラットフォームに依る } 上記がエラーになる環境として、JVM 環境があります。JVM 環境では、listOfによって生成されるのは Java のListインターフェースを実装しているArrays.ArrayListになります(これは add などの要素変更メソッドを実装していないことに注意してください)。 しかし、Listインターフェースには setter メソッド類も定義されているので、Kotlin の環境だと要素の編集機能も持っているとみなされてMutableList扱いになります。 したがって、実際には setter メソッド類の実装を持っていないArrays.ArrayListに対してaddが実行されることになってエラーになります。 Listインターフェース\nCopy in data classes (データクラスのコピーメソッド) Kotlin にはデータクラスという概念があります。 主にデータを(名前付きで)保持することを目的としたクラスですが、通常のクラス同様にメソッドを定義することもできます。\ndata class Person( val firstName : String, val familyName : String, val age : Int ) { fun getFullName() = firstName + familyName } data class では、通常のクラスと比較して以下の違いがあります。\n equals(), hashCode()の自動実装 copy()メソッドの実装(以下で紹介します)  上記の例では、人間一人に対して 1 インスタンスずつ生成するイメージでしょうか。 ところで、データクラスインスタンスを生成するときに、別のインスタンスの一部分のデータだけを変更すれば十分なことも頻繁にあります。 家族に対して子供を追加するときなどはその例だと思います(名前だけ違うけれども、苗字は一緒)。\nこのような場合、data class に備わっている copy()メソッドを使うことで、以下のように供インスタンスを作ることができます。\nval parent = Perosn(firstName = \u0026#34;m\u0026#34;, familyName = \u0026#34;t\u0026#34;, age = 27) val child = parent.copy(firstName = \u0026#34;n\u0026#34;, age = 0) 現実的にはちょっと気持ち悪い表現ではありますが、親をコピーして名前と年齢だけ変えて新しいインスタンスを作っています。\ncopy()メソッドがなぜこの節で登場するかというと、コピーの結果だけ見ると mutability の観点からはちょっと不思議なことが起きているからです。 コピーの結果を見ると、ひとまず parent のインスタンスのコピーを作ってしまって、firstName と age を書き換えたように見えないでしょうか?(プロパティはすべてvalなのに!)\nPerson クラスのプロパティは全部valなのに変更できるのか？という疑問がわくかもしれませんが、copy()メソッド内での変更(しているように見える部分)は、あくまで新しいインスタンスの初期化処理の一部分です。 コピー元から変更する必要のないプロパティについては、コピー元からそのまま引き継ぐような動作をします。 したがって、内容をちょっと変更したコピーを作るために、プロパティをvarにしたりする必要はないということになります。 プロパティを immutable に保ったままでこのような記述ができるので、とてもエレガントな手法ですね。\nDifferent kinds of mutation points(どこを可変にしようか？) 可変なコレクション(リスト)が必要になったとしましょう。 コレクションを変数化するときに、次の二つの書き方が思い浮かびます。\nval list1 = MutableList\u0026lt;Int\u0026gt; = mutableListOf() // 1.コレクションがmutableで、変数自体はimmutable var list2 = List\u0026lt;Int\u0026gt; = listOf() // 2.コレクションはimmutableで、変数自体がmutable 1.を使った場合、コレクション自体に要素を足し引きすることができます。\nlist1.add(1) 2.の場合、コレクションに add したりはできないので、要素を追加した新しいコレクションインスタンスでlist2を置き換える操作が必要になります。\nlist2 = list2 + 1 // 元のlist2と1を合わせた新しいListで置き換える この 2 つの例は、本文の言葉を借りれば mutation point (変更が生じうるポイント)が異なると言えます。 1.ではコレクション自体が mutation point、2. では変数そのものが mutation point になっています。 さて、どちらが優れているでしょうか？ 読みやすさという意味では 1.だと思います。なぜならほとんど人間の言語だからです。\nただし、マルチスレッドでこのコレクションの変更を行う場合では 2.の方が安全(な実装を行いやすい)です。 マルチスレッド処理では、複数のスレッドから同時に同じコレクションが変更されることを想定せねばなりません。 1.によるコレクションの変更を行う場合、実際に要素を書き換える処理は MutableList に任せることになります。 いかなる時も MutableList が適切なタイミングで処理を行ってくれるという保証はないので、潜在的に危険です。 一方、2.の実装を行っている場合、list2変数の変更タイミングさえきちんと synchronized にしておけば、マルチスレッドからの同時変更による問題は起きないことになります。\nもちろん、マルチスレッド処理においてどちらも安易な実装をすれば同時変更による問題を生じます。 実装 1.と 2.を比較したときに、mutation point が実装者側にある(=実装者が自由に制御できる)2.のパターンのほうが、安全な実装を行いやすいことになります。\n蛇足ですが、もちろん次のような実装はやるべきではありません。\nvar list3 = MutableList\u0026lt;Int\u0026gt; = mutableListOf() // コレクションの変更も変数の置き換えも両方できる mutation point を無意味に増やすのは避けましょう。\nDo not leak mutation points (mutation point は見えないように) Mutation point はよほどの理由がない限り、クラス外からは見えないようにするべきです。\nclass Contacts() { private val phoneNumbers = MutableList\u0026lt;String\u0026gt; = mutableListOf() fun getPhoneNumbers() = phoneNumbers } 上の例では、getPhoneNumbers()メソッドによって、登録されている電話番号のリストを取得できます。 それも mutable なリストとして。 ということで、getPhoneNumbers()が public である以上、誰でもいたずらで電話番号を書き換えることができてしまうわけです。 これは良くないですね。そもそもphoneNumbersを private にした意味がまるでありません。 対策としては、次の 2 点があげられます。\n 外部に提供するデータを data class 化して、外部からの要求に対しては常にcopy()メソッドの戻り値を渡す(defensive copy と呼ばれます) getPhoneNumbers()の戻り値の型をList\u0026lt;String\u0026gt;にアップキャストする  補足 Kotlin のコレクションはcopy()メソッドを実装していません。 コレクションに対して defensive copy を行いたいときは、下記のようにコレクション変換関数を使うとシンプルです。\nこの例では、ListからListへの変換なので、型は変わっておらず一見意味のない変換に見えます。 ここでのポイントは、これらコレクション変換関数で生成されるのは新しいコレクションインスタンスであるということです。 つまり、同じ型への変換関数の使用は、data class でいうコピーに相当します。\nclass Contacts() { private val phoneNumbers = MutableList\u0026lt;String\u0026gt; = mutableListOf() fun getPhoneNumbers() = phoneNumbers.toList() } mutation point は外から直接見えないようにして、外部から好き勝手に変更を加えられないように注意しましょう。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/","title":"Chapter 1: Safety(安全なコード)","tags":[],"description":"","content":"プロジェクトに Java でも C++でもなく Kotlin を用いるのでしょう。 その最大の理由は、Kotlin によるコーディングがもたらしてくれる\u0026quot;安全性\u0026quot;です。\n Item 1: Limit mutability(やたらと変更可能にしない)  更新日: 2021/12/11\n Item 2: Minimize the scope of variables(変数のスコープは最小化する)  更新日: 2021/12/20\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/","title":"Part 1: Good code(良いコードとは?)","tags":[],"description":"","content":" Chapter 1: Safety(安全なコード)  プロジェクトに Java でも C++でもなく Kotlin を用いるのでしょう。 その最大の理由は、Kotlin によるコーディングがもたらしてくれる\u0026quot;安全性\u0026quot;です。\n Chapter 2: Readability(読みやすいコード)  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/","title":"Item 19: do not repeat knowledge","tags":[],"description":"","content":"更新日: 2021/10/04\nこの節の内容は、言語にとらわれず意識しておくべき基礎的な原則です。\n まとめ  コーディングしている中で、コピペが必要になったときはちょっと立ち止まろう。同じことを二度書く必要はきっとないはず。 すべての変数やメソッドは変更されうる、という前提の下でコーディングしよう。 つまり無意味にコピペがあると、次の 2 つの理由で痛い目を見ます。  一つを変更したら全部変えなきゃ。面倒くさくない？ コピペしたところは一切もれなく(チームのほかの人がコピペしたものも含めて)把握している？たった一つでも見逃しているとその時点でバク発生！   ただし、何でもかんでも共通化してコピペを避けるべきというわけではない。共通化すべきかどうかの判断基準の一つは、片方を変更するときにもれなくもう片方も変更する必要があるか。 もしも別々に変更する可能性があるのであれば、それは共通化すべきでない。 なぜなら姿形はまったく同じでも意味の違うものであるから。 共通化にせよ分離にせよ、どちらかに極端に偏るといずれも良くない。 十分に訓練して、程よいバランスを保てるようにしよう。   ちょっと詳しく コーディングの原則としてよく知られている(しかし実践は実は難しい)\u0026ldquo;DRY (= Don\u0026rsquo;t Repeat Yourself) 原則\u0026quot;というものがあります。 平たく言えば、\u0026ldquo;同じ情報は 2 度書くのは良くないよ\u0026quot;という原則です。 まとめにある通り、1 つのプロジェクトの中でコピペをするということは、 どこかと同じ変数なりアルゴリズムなりを 2 度以上書いているということになります。 これは少なくとも下記の理由で避けるべきです。\n 単純に無駄だから。共通で使えるようにすればコーディングする時間もファイルサイズも 2 つ分は必要ないはずですよね。 1 つを変更しなくてはいけない時に死ぬほど面倒くさい。 なぜならコピペしたものを全部もれなく変更しなくてはいけないから。 DRY 原則に反したコーディングを、WET(= We Enjoy Typing, Waste Everyone\u0026rsquo;s Time, or Write Everything Twice) アンチパターンと呼んだりします。 DRY に対して WET、いい感じで対になってますね。  Knowledge -情報/知識- この節で言う\u0026quot;Knowledge\u0026quot;としては主に下記の 2 つに焦点を当てています。\nロジック: コードの振る舞いを記述するもの 共通アルゴリズム: ロジックを実現するための下回り計算 上記 2 つの違いはぱっと見わかりづらいものですが、ロジックはアプリケーションの要求に応じていつでも変わりうるもので、 それに対してアルゴリズムは、ロジックが変更されても基本的には変更されることのない仕組みの部分をさしています。\nEverything can change -すべてのものは変わりうる- ということで、世の中のありとあらゆるものは変化し続けます。 ソフトウェアについては特に変化が顕著で、長年一切の変化がないものはほとんど見つけることはできないでしょう。\n従って、自分が書いているコードはいつか必ず変更されるという前提に立っているべきなのです。 そして、いざ既存のコードを変更しようとしたとき、最も大きな障害となるのがロジックやデータの繰り返しです。 同じ意図で書かれた同じロジックやデータは、変更しようとしたときにもれなく更新する必要があります。\n 単純に時間と労力の無駄 どんなに気を付けていても変更漏れのリスクを避けられない  という観点で、繰り返しは避けるべきといえます。 コーディングの領域では、インターフェースなどの抽象化によってある程度変更しやすい(無駄な繰り返しを避けた)実装を行うことができます。\nWhen should we allow code repeatation? -コードを繰り返してもよいのはどんな時？- 一見同じコードが複数の場所に書かれていても問題がないケースもあります。 見た目は違っても意図が違う場合です。 一方を変更したときに他方も必ず変更する必要があるかが、コードの繰り返しに問題があるかどうかを判断する基準の一つとして有効です。 もし、独立に変更することが考えられるのであれば、一見同じコードが何か所かに書かれていても常には問題になりません。\nSingle responsibility principle -違う目的で使いまわさない- 目的が違う変数やメソッドは、(仮に見た目が全く同じであっても)一つにまとめるべきではありません。 何故なら、それらは今の見た目は同じであっても将来的に独立して変更される可能性があるからです。 言い換えると、本来別々であるべきものを、たまたま形が似ているからと言って定義を一緒にしてしまっているということになります。 もしこれらを一つのメソッドや変数にまとめてしまっていると、変更が生じたときには、変更がそれを利用しているすべてに及んでしまい、 思わぬバグを生むことになります。\n一つのクラス、変数、メソッドに一つの役割だけを持たせる (= Single responsibility prinsiple)ようにすべきです。\nサイト筆者の勝手な見解 ここまで\u0026quot;同じことは二度書くな\u0026quot;ということと、\u0026ldquo;必要以上に共通化しすぎると痛い目を見る\u0026quot;と両極端なことを述べてきました。 ここからはサイトの筆者の解釈ですが、コーディングをする際はやはり基本的には\u0026quot;同じことは二度書くな\u0026quot;の精神でいたほうが良いと思います。\nコードを共通化するためには、値や処理に対して変数やメソッド名として名前を付けてあげることとなります。 変数やメソッドに名前を付けるときに、名前の候補がいろいろと考えられて決めきれないときや、やたらと長い名前になってしまうときはまだ名づけるべき単位に分離しきれていないサインかもしれません。 ちょっと立ち止まって、変数やメソッド名を分離できないか考えるとよいかもしれませんね。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_2_minimize_the_scope_of_variables/","title":"Item 2: Minimize the scope of variables(変数のスコープは最小化する)","tags":[],"description":"","content":"更新日: 2021/12/20\nまとめ   変数のスコープはできるだけ小さくしましょう\n プロパティにする必要ありますか？ローカル変数で置き換えられないでしょうか？ 変数の宣言はできるだけ内側のスコープで。ループの中でしかつかなわいのであればループブロックの中で    変数スコープを小さくするメリットは次の通りです\n 変数が影響する範囲を小さくすることで、コードが読みやすくなる(特に状態変化を追いかける必要があるvar変数の場合は) 変数の利用範囲を狭めることで、本来の目的外で使われることを防げる 想定外の箇所で参照されるリスクを減らせる (Capturing 防止)    変数は宣言と同時にできるだけ初期化しましょう。if 文や Elvis operator を上手に使いましょう。\n   ちょっと詳しく valやvarで定義された変数は、それらが定義されたスコープの中でのみ参照することができます。 変数のスコープは、トップレベル定義の変数を除き、主に{}で囲まれたブロックにより形作られます。\nval numbers = listOf(1, 2, 3, 4, 5) var number: Int // number は forブロックの中からも外からも参照できる for (i in numbers.indices) { // iのスコープはforブロック内。forブロックの外側では参照できない。  number = numbers[i] println(\u0026#34;Number at $iis $number\u0026#34;) } 上の例では、変数としてnumbers: List\u0026lt;Int\u0026gt;, number: Int, i: Intの 3 つが利用されていますが、numberは明らかに大きすぎるスコープで定義されています。 numberは、\u0026ldquo;for 文中で、numbers から取り出した値の 1 つを表す\u0026quot;意図での変数ですので、for ブロック内でのみ利用できれば十分なはずです。 したがって、次の書き方のほうが良いです。\nval numbers = listOf(1, 2, 3, 4, 5) for (i in numbers.indices) { // iのスコープはforブロック内。forブロックの外側では参照できない。  val number = numbers[i] // スコープをforブロックに限定。さらに定義と同時に初期化。  println(\u0026#34;Number at $iis $number\u0026#34;) } この例では、スコープを for ブロックに限定することに加えてもう 1 つ工夫をしています。 変数の定義と同時に初期化していることです(さらに immutable なvalにできる)。 numberがどんな状態なのかは、その定義のたった 1 行読めば十分理解できますので、明らかに先の例よりも読みやすくなっているかと思います。\nnumberの状態、すなわち何を表す何が代入されいているのかが見やすくなるのはもちろんですが、number変数の意味を限定することもできています。 先の例でのnumber変数は、\u0026ldquo;何かしらの数字を表す\u0026quot;という意味しか与えられません。なぜなら for ブロックの外でも変更されたり参照されたりする可能性があるからです(もちろん、for ブロックの中だけを見れば\u0026quot;for 文中で、numbers から取り出した値の 1 つを表す\u0026quot;という意図はつかめる)。\n以上より、変数のスコープをできるだけ小さくすることには、次のメリットがあると考えられます。\n 変数の状態が小さい範囲で確定するので、コードが読みやすくシンプルになる スコープを限定することは意味を限定することに等しい。1 つの変数を複数の意味で過剰に利用することを防止できる。  Capturing (ずっと参照され続ける変数) 変数を必要以上に大きなスコープで定義してしまうと、思わぬ不具合を引き起こす場合があります。 この節では、変数の Capturing について紹介します。\n例として、\u0026ldquo;エラトステネスのふるい\u0026quot;による、素数計算を取り上げます。 素数とは、1 と自分自身以外で割り切ることができない 2 以上の自然数のことですが、次のようなアルゴリズムによってシンプルに計算することができます。\n 2 から始まる自然数の昇順 List を用意します(numbers = listOf(2, 3, 4, 5, ...)) 初めの要素は 2 であり、これは素数ですので素数としてメモしておきます 2 で割り切れる自然数はもはや素数ではありませんので、numbersの要素のうち、2 で割り切れる数はすべて捨てます 2 で割り切れる数を取り除き切った段階で、numbersの次の要素は 3 です 3 は次の素数ですので、またメモしておきます 3 で割り切れる数はやはり素数ではありえませんので、numbersからは捨てます numbersの次の先頭の要素は 5 で、これは次の素数になります 5 で割り切れる数は素数ではありえませんので…  という計算を繰り返していくと、numbersの先頭の要素は常に素数となり、次々と素数を見つけることができます。 ところで、素数は無限にあることがわかっているため、実際にList\u0026lt;Int\u0026gt;によって計算していくと、計算が終わることはありません。 そこで、Sequenceによる遅延計算を行うことで、いつまでたっても計算が終わらないという状況を避けることができます(ただし、とても大きい素数を見つけようとするとおそろしく時間がかかります)。\nprivate fun primeNumbersBySieveOfEratosthenes(): Sequence\u0026lt;Int\u0026gt; = sequence { var numbers = generateSequence(2) { it + 1 } while (true) { val prime = numbers.first() // ループの度に変数生成しているのムダっぽい?  yield(prime) numbers = numbers.drop(1).filter { it % prime != 0 } } } // はじめの10個は [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ところで、whileループの中で毎回変数primeを生成していますが、なんだか無駄っぽくないでしょうか。 変数primeは、ループの外でvar変数として定義して、無駄を省いたのが次のコードです。\nprivate fun primeNumbersBySieveOfEratosthenes(): Sequence\u0026lt;Int\u0026gt; = sequence { var numbers = generateSequence(2) { it + 1 } var prime: Int while (true) { prime = numbers.first() yield(prime) numbers = numbers.drop(1).filter { it % prime != 0 } } } // はじめの10個は [2, 3, 5, 6, 7, 8, 9, 10, 11, 12] 効率化したつもりでしたが、肝心の結果が間違っていることがわかります。 これが、変数の Capturing によって起きた問題です。\n何が起こっているのかを正しく理解するには Kotlin のSequenceの動作を理解している必要がありますが、簡単に紹介します(ちなみに Effective Kotlin 原文の説明も間違っています)。 Sequenceは値の計算を、その値が要求される時点まで遅延します。 そのため、素数計算のようないつまでたっても終わることのない値の計算でも有限の値であれば有限の時間で計算することができるわけです。 上記で紹介したSequenceによる素数計算と(ほぼ)等価なコードを初めの 5 個の素数について書いてみると次のようになります。\nprivate fun naiveSieveOfEratosthenes(): List\u0026lt;Int\u0026gt; { var numbers = mutableListOf(2, 3, 4, 5, 6, 7, 8, 9, 10, 11) var primes = mutableListOf\u0026lt;Int\u0026gt;() val prime1 = numbers.first() primes.add(prime1) numbers = numbers.drop(1).filter { it % prime1 != 0 }.toMutableList() val prime2 = numbers.first() primes.add(prime2) numbers = numbers.drop(1).filter { it % prime2 != 0 }.toMutableList() val prime3 = numbers.first() primes.add(prime3) numbers = numbers.drop(1).filter { it % prime3 != 0 }.toMutableList() val prime4 = numbers.first() primes.add(prime4) numbers = numbers.drop(1).filter { it % prime4 != 0 }.toMutableList() val prime5 = numbers.first() primes.add(prime5) numbers = numbers.drop(1).filter { it % prime5 != 0 }.toMutableList() return primes } これは、素数探索が上手く動く例です。 ループを展開して書くと少し分かりやすいですが、ループ内で変数を定義すると、都度新しい変数でフィルタリングされることが分かります。 フィルタがどんどん追加されていっているイメージです。\n一方、正しく動かない方を始めの 5 つについて展開すると次のようになります。\nprivate fun naiveSieveOfEratosthenes(): List\u0026lt;Int\u0026gt; { var numbers = mutableListOf(2, 3, 4, 5, 6, 7, 8, 9, 10, 11) var primes = mutableListOf\u0026lt;Int\u0026gt;() var prime: Int prime = numbers.first() primes.add(prime) numbers = numbers.drop(1).filter { it % prime != 0 }.toMutableList() prime = numbers.first() primes.add(prime) numbers = numbers.drop(1).filter { it % prime != 0 }.toMutableList() prime = numbers.first() primes.add(prime) numbers = numbers.drop(1).filter { it % prime != 0 }.toMutableList() prime = numbers.first() primes.add(prime) numbers = numbers.drop(1).filter { it % prime != 0 }.toMutableList() prime = numbers.first() primes.add(prime) numbers = numbers.drop(1).filter { it % prime != 0 }.toMutableList() return primes } ループ外で宣言した mutable な変数primeを全ループで使いまわしていることになります。 これを見ると、{ it % prime != 0 }のフィルターがほぼ意味をなしていないことがよくわかります。 変数primeの値は、ループごとに常に最新の素数(なのは最初だけですが)で更新されてしまうため、幾十のフィルターを追加しているように見える部分も、実際は最新のprimeで割り切れる数を除外するだけのただ一つのフィルターになっています。\nこのように、スコープを広げるということは、その変数が参照(Capture)される範囲を広げてしまうことになる場合があります。 さらに、多くの場合 変数の capturing は気づきにくいため、原理的に起こりえなくするのが有効な対策であり、 その一つの手段が変数のスコープは最小限にとどめるということなのです。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_2/","title":"Chapter 2: Readability(読みやすいコード)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/","title":"Part 2: Code design(コード設計)","tags":[],"description":"","content":" Chapter 3: Reusability(再利用性)  コードは再利用しやすいように書こうね、という話。\n Chapter 4: Abstraction design(抽象化設計)  \n Chapter 5: Object creation(インスタンス生成)  \n Chapter 6: Class design(クラス設計)  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/","title":"Part 3: Efficiency(効率の良いコード)","tags":[],"description":"","content":" Make it cheap  \n Efficient collection processing  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/","title":"Chapter 3: Reusability(再利用性)","tags":[],"description":"","content":"コードは再利用しやすいように書こうね、という話。\n Item 19: do not repeat knowledge  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_4/","title":"Chapter 4: Abstraction design(抽象化設計)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_5/","title":"Chapter 5: Object creation(インスタンス生成)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_6/","title":"Chapter 6: Class design(クラス設計)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/chapter_7/","title":"Make it cheap","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/chapter_8/","title":"Efficient collection processing","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/","title":"コレクションの deep copy が欲しい","tags":[],"description":"","content":"更新日: 2021/9/12\nまとめ  toList, toSet, toMap などの、コレクションの変換メソッドで得られるのは\u0026quot;浅いコピー\u0026quot; (Shallow copy) コレクションそのものは変換元とは別インスタンスなるが、プリミティブ型以外の要素は参照のコピーなので、目的に合ったコピーになっているか注意が必要 data class の copy()メソッドによるコピーも、実際は shallow copy。プリミティブ型以外のプロパティについては元のインスタンスと同じ参照を持つ Kotlin 組み込みの実装だけによって deep copy を作ることは現状できない。クラスごとに deep copy 用のメソッドを自力で実装するのが単純。   インスタンスのコピー toList, toSet など、コレクションを変換、コピーすることができるメソッドが Kotlin には用意されています。この時、コレクションの要素も deep copy されると思い込んではまったお話。\n値やインスタンスの集合であるコレクション(List, Set, Map など)を丸ごとコピーしたい場合は、下記のように toList, toSet, toMap など、目的の型への変換メソッドを使うことでコピーが行えます。 to~はコレクションの変換メソッドとして紹介されることが多いですが、変換元の型と同じ型への変換メソッドを使うと、中身が同じだけれども別インスタンスとしてのコレクション(コピー)を得ることができます。 ただし、プリミティブ型以外の要素は、 shallow copy が作られるだけで、参照先は変わりません。\n下記を例にとってみます。 Person クラスを要素に持つ List を、 toList() メソッドによってコピーしています。生成されたコピーに対して、一つ目の要素の値を書き換えてみます。\ndata class Person( var name: String ) fun shallowCopy() { val family = listOf( Person(\u0026#34;a\u0026#34;), Person(\u0026#34;b\u0026#34;) ) val shallowCopiedFamily = family.toList() // 一人目の名前を変えちゃう  shallowCopiedFamily.first().name = \u0026#34;c\u0026#34; println(\u0026#34;family = $family\u0026#34;) println(\u0026#34;copiedFamily = $shallowCopiedFamily\u0026#34;) } 要素を書き換えた後のそれぞれの List を出力してみると下記のようになります。 これは、toList()によるコピーが shallow copy だからです。 生成されたリスト自体は元のインスタンスと別物ですが、中に含まれるインスタンスは下図のように同じ場所を参照しています。\nfamily = [Person(name=c), Person(name=b)] copiedFamily = [Person(name=c), Person(name=b)] プリミティブ型以外の要素を持つコレクションをディープコピーしたい場合は、下記のように一工夫必要となります。\nfun deepCopy() { val family = listOf( Person(\u0026#34;a\u0026#34;), Person(\u0026#34;b\u0026#34;) ) val deepCopiedFamily = family.map { member -\u0026gt; member.copy() } // 一人目の名前を変えちゃう  deepCopiedFamily.first().name = \u0026#34;c\u0026#34; println(\u0026#34;family = $family\u0026#34;) println(\u0026#34;copiedFamily = $deepCopiedFamily\u0026#34;) } family = [Person(name=a), Person(name=b)] copiedFamily = [Person(name=c), Person(name=b)] 一例でしかありませんが、この例では map()メソッドによって要素を逐一コピーしたものを新しく生成されるコレクションの要素に与えています。 インスタンスに対して copy()メソッドを実行すると、そのインスタンスの deep copy が返されます。 これを新しいコレクションの要素とすれば、各要素の deep copy で構成されたコレクションが得られます。\nプリミティブ型は例外 プリミティブ型については、to~によるコピーで別の値としてのコピーが作成されます(そもそもプリミティブ型に対して copy()メソッドは定義されていない)。\nfun primitiveCopy() { val list = listOf(0, 1) val copiedList = list.toMutableList() // コピーしたリストの要素をいじってみる  copiedList[0] = 2 println(\u0026#34;list = $list\u0026#34;) println(\u0026#34;copiedList = $copiedList\u0026#34;) } list = [0, 1] copiedList = [2, 1] 試しにやってみると、単に toList()によって(要素をいじりたいので実際は toMutableList()によって)作られたコピーの要素をいじってみても、元の要素に変更はないことがわかります。\ncopy メソッドでも shallow copy が作られる (2021/9/21 追記) data class の　copy() メソッドに関して訂正です。 deep copy が欲しければ data class の copy() メソッドを使えばよいと上で述べましたが、実際に生成されるのは shallow copy のため、状況によっては不適切です。\n\u0026ldquo;状況によっては\u0026quot;というのも、コピーしたい data class のプロパティがプリミティブ型のみであれば、実際は deep copy の生成とみなせますので問題は起こらないはずです。問題が起こりうるのは、下記のようにインスタンスをプロパティとして保持している場合です。\ndata class Container(val content: Content) data class Content(var id: Int) fun instanceProperty() { val content = Content(0) val container = Container(content) val copiedContainer = container.copy() copiedContainer.content.id = 1 println(\u0026#34;content in container = $container\u0026#34;) println(\u0026#34;content in copiedContainer = $copiedContainer\u0026#34;) } 実行結果は下記のようになり、 Container クラスのプロパティである content インスタンスは元の参照と同じものを持っているため、コピー先への変更がコピー元が保持している content にまで及んでいることがわかります。\ncontent in container = Container(content=Content(id=1)) content in copiedContainer = Container(content=Content(id=1)) こういったケースで deep copy が必要になる場合は Container クラスに自力で copy メソッドを実装して、プロパティのインスタンスも copy によってコピーするのが単純でしょうか…。\ndata class Container(val content: Content) { fun copy() = Container(content.copy()) // 手動コピー } data class Content(var id: Int) 上記のコードで一応の目的は果たせることになりますが、拡張性もメンテナンス性も最悪です。 Container クラスを拡張した場合は忘れずに独自実装の copy() メソッドも修正する必要があります(が、質の悪いことに修正を忘れてもコンパイルは通ってしまいます)。\n調べてみると、 deep copy を生成するためのライブラリも公開されているようです。\nコピーなんて単純だと思っていましたが、目的にあったコピーは意外と難しいものでした…。スマートなアイディアをお持ちの方、ぜひ筆者に教えてください。\n"},{"uri":"https://mtakamur.github.io/kotlin/struggled/","title":"ハマったこと","tags":[],"description":"","content":"思った通りにならなくて、解決に時間がかかってしまったことです。誰かの役に立つことを願って。\n コレクションの deep copy が欲しい  更新日: 2021/9/12\n data class copy() の対象  更新日: 2021/9/13\n"},{"uri":"https://mtakamur.github.io/kotlin/struggled/target_of_copy/","title":"data class copy() の対象","tags":[],"description":"","content":"更新日: 2021/9/13\nまとめ  data class のプロパティは、特に理由がない限りはプライマリコンストラクタ中で宣言したほうが良い プライマリコンストラクタ意外で定義したプロパティは、equals(), hashCode(), copy()メソッドの生成時に考慮されない   data class の copy()メソッドは primary constructor に基づく data class を作ると、Kotlin 側で自動的に下記の 5 つのメソッドを実装してくれ、私たちは特に気にしなくても便利にデータクラスを使えるのでした。\n equals(): プロパティの同一性を true / false の 2 値で返してくれるメソッド hashCode(): プロパティを基に一意なハッシュ値を生成してくれるメソッド toString(): インスタンスを文字列出力したときのフォーマット componentN(): N 番目のプロパティへのアクセサ copy(): 元のプロパティと同じ値を持った別のインスタンスを生成してくれるメソッド 今回は、copy() メソッドではいかなるプロパティも自動でコピーしてくれると思っていてハマったお話です。  結論として、copy() メソッドでコピーしてくれるのは data class の primary constructor で宣言されているプロパティのみです。データクラスの実装上、 コンストラクタ以外の部分でもプロパティを定義することができますが、それらは copy() メソッドの対象外になってしまうので注意が必要です。 このことは公式ドキュメントにも(分かりづらいですが)ちゃんと書いてありました。自動的に生成される 5 メソッドは、あくまでプライマリコンストラクタで宣言されたプロパティだけを対象として生成されるということですね。\n例えば下記のような実装をすると、isAdult は data class Human のプロパティではありますが、 copy() メソッドで値がコピーされません。\ndata class Human( val name: String, val age: Int, ){ var isAdult: Boolean = false // コンストラクタ外での定義  } fun notCopied() { val human = Human(name = \u0026#34;mtakamur\u0026#34;, age = 27) if (human.age \u0026gt;= 20) human.isAdult = true // プロパティを更新  val copiedHuman = human.copy() println(\u0026#34;human = $human, isAdult = ${human.isAdult}\u0026#34;) println(\u0026#34;copiedHuman = $copiedHuman, isAdult = ${copiedHuman.isAdult}\u0026#34;) }  human = Human(name=mtakamur, age=27), isAdult = true copiedHuman = Human(name=mtakamur, age=27), isAdult = false // 変えたはずなのに…。 isAdult の定義をちゃんとプライマリコンストラクタに移動してあげると、isAdult も copy() によって複製されるようになります。\nそもそもデータクラス(値の塊をパックする入れ物)という概念上、上記のような実装は避けるべきかもしれません。コンストラクタ以外の場所でプロパティを定義したい場合には下記のようにすると安全そうです。\ndata class ModifiedHuman( val name: String, val age: Int ) { val isAdult = age \u0026gt;= 20 } ポイントはコンストラクタ外のプロパティの値は、コンストラクタで宣言されている値のみに依存させるということです。 そうしておけば、copy() 時にもコンストラクタで宣言されている値を追いかけることができるようになります。\n"},{"uri":"https://mtakamur.github.io/kotlin/others/","title":"その他","tags":[],"description":"","content":"どこのジャンルに入れていいかわからなかった、けど知っておくと便利なことをつらつらと。\n Trailing commas  "},{"uri":"https://mtakamur.github.io/flutter/","title":"Flutter","tags":[],"description":"","content":"Google 製マルチプラットフォーム SDK。 Dart 言語による実装で、Windows, Mac, Android, iOS, Linux など、様々なプラットフォーム上で動くアプリが単一ソースで実現できるらしい。\nあまり流行っていない Dart 言語もこれで普及??\n Flutter SDKのセットアップ  flutter doctor が通らない人へ。\n"},{"uri":"https://mtakamur.github.io/kotlin/","title":"Kotlin","tags":[],"description":"","content":"Android 開発の公式言語に。 Java と比べると安全で読みやすいコードが書きやすい印象。\n ハマったこと  思った通りにならなくて、解決に時間がかかってしまったことです。誰かの役に立つことを願って。\n その他  どこのジャンルに入れていいかわからなかった、けど知っておくと便利なことをつらつらと。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/","title":"忙しい人のための Effective Kotlin","tags":[],"description":"","content":"Effective なんちゃらシリーズの Kotlin 版。まだ日本語版が出版されていませんし、総ページ数 400 ページ余りとなかなかのボリュームなので、手を出しづらい方もいらっしゃるでしょう。 そんな忙しい方のために、要点だけをちょこちょこお届け。 なるべくセクションごとのまとめを心がけますが、執筆順不同です。誤訳も多分ありますので悪しからず。\n Part 1: Good code(良いコードとは?)  \n Part 2: Code design(コード設計)  \n Part 3: Efficiency(効率の良いコード)  \n"},{"uri":"https://mtakamur.github.io/flutter/setup_flutter_sdk/","title":"Flutter SDKのセットアップ","tags":[],"description":"","content":"flutter doctor が通らない人へ。\nFlutter による開発を始めるためのセットアップ手順は、公式サイトに丁寧にまとめられています。 セットアップの手順については、公式ページの指示に則って進めれば迷うことはなさそうです。\n公式ページで案内がある、flutter doctorコマンドが no issue で通ればすべての開発環境セットアップは完了です。 flutter doctorコマンドは、Flutter による開発環境が正しくセットアップされているかを確認してくれるコマンドで、いろいろな項目について一通り状態をチェックしてくれます。 doctor によるチェックがすべて通っていれば、Flutter 開発環境はめでたく完成となります。\nPS C:\\Users\\hogehoge\u0026gt; flutter doctor Doctor summary (to see all details, run flutter doctor -v): [√] Flutter (Channel stable, 3.0.1, on Microsoft Windows [Version 10.0.19043.1706], locale ja-JP) [√] Android toolchain - develop for Android devices (Android SDK version 32.1.0-rc1) [√] Chrome - develop for the web [√] Visual Studio - develop for Windows (Visual Studio Community 2019 16.11.15) [√] Android Studio (version 2021.2) [√] IntelliJ IDEA Community Edition (version 2022.1) [√] VS Code, 64-bit edition (version 1.63.2) [√] Connected device (4 available) [√] HTTP Host Availability • No issues found! 上記が正常にセットアップが完了している場合のflutter doctorの実行結果です。すべての項目にチェックマークが入っていることがわかります。\n上記チェック項目をよく見るとわかりますが、Android toolchain や Visual Studio のセットアップ状況についてもflutter doctorコマンドによってチェックされていることがわかります。 Android Studio や Visual Studio が既にインストールされている環境で何の準備もなく flutter doctor コマンドを実行すると、 Android toolchain や Visual Studio の項目でエラーになるケースがあります。 これらについて、公式ページの instruction では「ダメな項目があったら解決しといてね」くらいのことしか書いていないので、解決方法を示します。\nAndroid toolchain の項 Android Studio デフォルトインストールだけではインストールされない SDK が Flutter によって要求されますので、手動で追加インストールを行う必要があります。 Android Studio のスタート画面から、SDK manager を開きます。\n続いて、SDK Tools タブから \u0026ldquo;Android SDK Command-line Tools\u0026quot;をチェックします。これが、flutter doctorで不足していると指摘されたパッケージです。 あとは、画面下部の\u0026quot;Apply\u0026quot;ボタンで変更を適用すれば、Android Studio で必要なツールのインストールは完了です。 Android toolchain のインストールが完了したら、今度は利用規約への同意が必要となります。 こちらについては公式ページにも案内がありますので、それに従って shell やコマンドプロンプト上でコマンドを実行します。 何やらたくさんメッセージが表示されるので、よーく読んで承諾します。 数項目承諾が必要となり、すべての項目への承諾が完了すると、はれてセットアップ完了です。\nVisual Studio の項 開発を Visual Studio で行う場合にはこちらのセットアップも必要です。\nVisual Studio を起動し、ツールタブから「ツールと機能を取得」を選択します。 表示された画面で\u0026quot;C++によるデスクトップ開発\u0026quot;にチェックを入れ、インストールを実行します。 Android toolchain と Visual Studio のセットアップが終わったら 再びflutter doctorコマンドを実行してみましょう。 全項目のチェックがパスしていることが確認出来たら、Flutter の開発環境の完成です!\n"},{"uri":"https://mtakamur.github.io/kotlin/others/trailing_commas/","title":"Trailing commas","tags":[],"description":"","content":"まとめ  Kotlin 1.4 以降ではコレクションやメソッド引数の最終要素に\u0026quot;,\u0026quot; (trailing comma) を残しておいてもコンパイルエラーになりません trailing comma があってもなくてもコードの動作は一切変わりません trailing comma をつけるようにしておくと、チーム開発するときのレビューがしやすくなります (コレクションやメソッドの引数に変更を加えても、追加削除した行だけが変更点として表示されるから)   Trailing comma (末尾のカンマ) コレクションの要素やメソッドのパラメータなど、同列の要素を複数個並べたいときは下記のようにカンマで区切って並べます。 この時、最後の要素の後には\u0026quot;,\u0026ldquo;を書かないのが一般的かと思います。 実際、Kotlin 1.4 より古いバージョンでは、余分なコンマを付けているとコンパイルエラーになります。\nval colors = listOf( \u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34; // \u0026lt;-ここにはカンマをつけていない  ) ところが Kotlin 1.4 以降では、最終要素の後ろにも\u0026rdquo;,\u0026ldquo;を残しておいて OK になりました。 この余分なカンマのことを trailing comma と呼びます。\nなにがうれしい？ trailing comma があってもなくてもコードの動作には一切影響ありません。\ntrailing comma が若干ありがたく感じるのは、チームで開発を進めて、お互いにコードをレビューしあうような状況でしょうか。 開発を進めていくと、既存のメソッドにパラメータを追加したり、逆に削除したくなることはよくあるかと思いますが、この時に \u0026ldquo;これは最後の要素だからカンマを消して…\u0026rdquo; とか考える必要がなくなります。 カンマの追加/削除が本質的な変更点ではありえないでしょうから、余計な変更を加える必要がなくなり、コードレビューをするときも、本質的な変更点だけに集中することができるようになります。\n配列やパラメータの順番だけを変更するときも幾分やりやすくなっているかと思います。 カンマのあるなしは気にせず、配列の行丸ごとの置換で OK になります。公式ドキュメントにもその旨記述があります。 多分ありがたいのはこれくらいでしょうか。\nコンマ？カンマ？ 今さらコンマとカンマで表記ゆれがあることに気づきました…。 アドバイスとアドヴァイスみたいな。 カタカナで発音を表現しようとしている時点で間違ってますから、どっちでもいいですよね。\n"},{"uri":"https://mtakamur.github.io/","title":"Pi fruit","tags":[],"description":"","content":"Pi fruit  Dart  Google 製の開発言語。 Web アプリケーション開発をはじめ、Flutter によるマルチプラットフォームアプリの開発にも使われます。\nGoogle による公式ページはこちら\n Flutter  Google 製マルチプラットフォーム SDK。 Dart 言語による実装で、Windows, Mac, Android, iOS, Linux など、様々なプラットフォーム上で動くアプリが単一ソースで実現できるらしい。\nあまり流行っていない Dart 言語もこれで普及??\n Kotlin  Android 開発の公式言語に。 Java と比べると安全で読みやすいコードが書きやすい印象。\n 忙しい人のための Effective Kotlin  Effective なんちゃらシリーズの Kotlin 版。まだ日本語版が出版されていませんし、総ページ数 400 ページ余りとなかなかのボリュームなので、手を出しづらい方もいらっしゃるでしょう。 そんな忙しい方のために、要点だけをちょこちょこお届け。 なるべくセクションごとのまとめを心がけますが、執筆順不同です。誤訳も多分ありますので悪しからず。\n "},{"uri":"https://mtakamur.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]