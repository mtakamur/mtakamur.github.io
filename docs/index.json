[{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/","title":"Chapter 1: Safety(安全なコード)","tags":[],"description":"","content":"プロジェクトに Java でも C++でもなく Kotlin を用いるのでしょう。 その最大の理由は、Kotlin によるコーディングがもたらしてくれる\u0026quot;安全性\u0026quot;です。\n Item 1: Limit mutability(やたらと変更可能にしない)  更新日: 2021/10/04\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/","title":"Part 1: Good code(良いコードとは?)","tags":[],"description":"","content":" Chapter 1: Safety(安全なコード)  プロジェクトに Java でも C++でもなく Kotlin を用いるのでしょう。 その最大の理由は、Kotlin によるコーディングがもたらしてくれる\u0026quot;安全性\u0026quot;です。\n Chapter 2: Readability(読みやすいコード)  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/","title":"Item 19: do not repeat knowledge","tags":[],"description":"","content":"更新日: 2021/10/04\nこの節の内容は、言語にとらわれず意識しておくべき基礎的な原則です。\n まとめ  コーディングしている中で、コピペが必要になったときはちょっと立ち止まろう。同じことを二度書く必要はきっとないはず。 すべての変数やメソッドは変更されうる、という前提の下でコーディングしよう。 つまり無意味にコピペがあると、次の 2 つの理由で痛い目を見ます。  一つを変更したら全部変えなきゃ。面倒くさくない？ コピペしたところは一切もれなく(チームのほかの人がコピペしたものも含めて)把握している？たった一つでも見逃しているとその時点でバク発生！   ただし、何でもかんでも共通化してコピペを避けるべきというわけではない。共通化すべきかどうかの判断基準の一つは、片方を変更するときにもれなくもう片方も変更する必要があるか。 もしも別々に変更する可能性があるのであれば、それは共通化すべきでない。 なぜなら姿形はまったく同じでも意味の違うものであるから。 共通化にせよ分離にせよ、どちらかに極端に偏るといずれも良くない。 十分に訓練して、程よいバランスを保てるようにしよう。   ちょっと詳しく コーディングの原則としてよく知られている(しかし実践は実は難しい)\u0026ldquo;DRY (= Don\u0026rsquo;t Repeat Yourself) 原則\u0026quot;というものがあります。 平たく言えば、\u0026ldquo;同じ情報は 2 度書くのは良くないよ\u0026quot;という原則です。 まとめにある通り、1 つのプロジェクトの中でコピペをするということは、 どこかと同じ変数なりアルゴリズムなりを 2 度以上書いているということになります。 これは少なくとも下記の理由で避けるべきです。\n 単純に無駄だから。共通で使えるようにすればコーディングする時間もファイルサイズも 2 つ分は必要ないはずですよね。 1 つを変更しなくてはいけない時に死ぬほど面倒くさい。 なぜならコピペしたものを全部もれなく変更しなくてはいけないから。 DRY 原則に反したコーディングを、WET(= We Enjoy Typing, Waste Everyone\u0026rsquo;s Time, or Write Everything Twice) アンチパターンと呼んだりします。 DRY に対して WET、いい感じで対になってますね。  Knowledge -情報/知識- この節で言う\u0026quot;Knowledge\u0026quot;としては主に下記の 2 つに焦点を当てています。\nロジック: コードの振る舞いを記述するもの 共通アルゴリズム: ロジックを実現するための下回り計算 上記 2 つの違いはぱっと見わかりづらいものですが、ロジックはアプリケーションの要求に応じていつでも変わりうるもので、 それに対してアルゴリズムは、ロジックが変更されても基本的には変更されることのない仕組みの部分をさしています。\nEverything can change -すべてのものは変わりうる- ということで、世の中のありとあらゆるものは変化し続けます。 ソフトウェアについては特に変化が顕著で、長年一切の変化がないものはほとんど見つけることはできないでしょう。\n従って、自分が書いているコードはいつか必ず変更されるという前提に立っているべきなのです。 そして、いざ既存のコードを変更しようとしたとき、最も大きな障害となるのがロジックやデータの繰り返しです。 同じ意図で書かれた同じロジックやデータは、変更しようとしたときにもれなく更新する必要があります。\n 単純に時間と労力の無駄 どんなに気を付けていても変更漏れのリスクを避けられない  という観点で、繰り返しは避けるべきといえます。 コーディングの領域では、インターフェースなどの抽象化によってある程度変更しやすい(無駄な繰り返しを避けた)実装を行うことができます。\nWhen should we allow code repeatation? -コードを繰り返してもよいのはどんな時？- 一見同じコードが複数の場所に書かれていても問題がないケースもあります。 見た目は違っても意図が違う場合です。 一方を変更したときに他方も必ず変更する必要があるかが、コードの繰り返しに問題があるかどうかを判断する基準の一つとして有効です。 もし、独立に変更することが考えられるのであれば、一見同じコードが何か所かに書かれていても常には問題になりません。\nSingle responsibility principle -違う目的で使いまわさない- 目的が違う変数やメソッドは、(仮に見た目が全く同じであっても)一つにまとめるべきではありません。 何故なら、それらは今の見た目は同じであっても将来的に独立して変更される可能性があるからです。 言い換えると、本来別々であるべきものを、たまたま形が似ているからと言って定義を一緒にしてしまっているということになります。 もしこれらを一つのメソッドや変数にまとめてしまっていると、変更が生じたときには、変更がそれを利用しているすべてに及んでしまい、 思わぬバグを生むことになります。\n一つのクラス、変数、メソッドに一つの役割だけを持たせる (= Single responsibility prinsiple)ようにすべきです。\nサイト筆者の勝手な見解 ここまで\u0026quot;同じことは二度書くな\u0026quot;ということと、\u0026ldquo;必要以上に共通化しすぎると痛い目を見る\u0026quot;と両極端なことを述べてきました。 ここからはサイトの筆者の解釈ですが、コーディングをする際はやはり基本的には\u0026quot;同じことは二度書くな\u0026quot;の精神でいたほうが良いと思います。\nコードを共通化するためには、値や処理に対して変数やメソッド名として名前を付けてあげることとなります。 変数やメソッドに名前を付けるときに、名前の候補がいろいろと考えられて決めきれないときや、やたらと長い名前になってしまうときはまだ名づけるべき単位に分離しきれていないサインかもしれません。 ちょっと立ち止まって、変数やメソッド名を分離できないか考えるとよいかもしれませんね。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_2/","title":"Chapter 2: Readability(読みやすいコード)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/","title":"Part 2: Code design(コード設計)","tags":[],"description":"","content":" Chapter 3: Reusability(再利用性)  コードは再利用しやすいように書こうね、という話。\n Chapter 4: Abstraction design(抽象化設計)  \n Chapter 5: Object creation(インスタンス生成)  \n Chapter 6: Class design(クラス設計)  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/","title":"Part 3: Efficiency(効率の良いコード)","tags":[],"description":"","content":" Make it cheap  \n Efficient collection processing  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/","title":"Chapter 3: Reusability(再利用性)","tags":[],"description":"","content":"コードは再利用しやすいように書こうね、という話。\n Item 19: do not repeat knowledge  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_4/","title":"Chapter 4: Abstraction design(抽象化設計)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_5/","title":"Chapter 5: Object creation(インスタンス生成)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_6/","title":"Chapter 6: Class design(クラス設計)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/chapter_7/","title":"Make it cheap","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/chapter_8/","title":"Efficient collection processing","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/","title":"コレクションの deep copy が欲しい","tags":[],"description":"","content":"更新日: 2021/9/12\nまとめ  toList, toSet, toMap などの、コレクションの変換メソッドで得られるのは\u0026quot;浅いコピー\u0026quot; (Shallow copy) コレクションそのものは変換元とは別インスタンスなるが、プリミティブ型以外の要素は参照のコピーなので、目的に合ったコピーになっているか注意が必要 data class の copy()メソッドによるコピーも、実際は shallow copy。プリミティブ型以外のプロパティについては元のインスタンスと同じ参照を持つ Kotlin 組み込みの実装だけによって deep copy を作ることは現状できない。クラスごとに deep copy 用のメソッドを自力で実装するのが単純。   インスタンスのコピー toList, toSet など、コレクションを変換、コピーすることができるメソッドが Kotlin には用意されています。この時、コレクションの要素も deep copy されると思い込んではまったお話。\n値やインスタンスの集合であるコレクション(List, Set, Map など)を丸ごとコピーしたい場合は、下記のように toList, toSet, toMap など、目的の型への変換メソッドを使うことでコピーが行えます。 to~はコレクションの変換メソッドとして紹介されることが多いですが、変換元の型と同じ型への変換メソッドを使うと、中身が同じだけれども別インスタンスとしてのコレクション(コピー)を得ることができます。 ただし、プリミティブ型以外の要素は、 shallow copy が作られるだけで、参照先は変わりません。\n下記を例にとってみます。 Person クラスを要素に持つ List を、 toList() メソッドによってコピーしています。生成されたコピーに対して、一つ目の要素の値を書き換えてみます。\ndata class Person( var name: String ) fun shallowCopy() { val family = listOf( Person(\u0026#34;a\u0026#34;), Person(\u0026#34;b\u0026#34;) ) val shallowCopiedFamily = family.toList() // 一人目の名前を変えちゃう  shallowCopiedFamily.first().name = \u0026#34;c\u0026#34; println(\u0026#34;family = $family\u0026#34;) println(\u0026#34;copiedFamily = $shallowCopiedFamily\u0026#34;) } 要素を書き換えた後のそれぞれの List を出力してみると下記のようになります。 これは、toList()によるコピーが shallow copy だからです。 生成されたリスト自体は元のインスタンスと別物ですが、中に含まれるインスタンスは下図のように同じ場所を参照しています。\nfamily = [Person(name=c), Person(name=b)] copiedFamily = [Person(name=c), Person(name=b)] プリミティブ型以外の要素を持つコレクションをディープコピーしたい場合は、下記のように一工夫必要となります。\nfun deepCopy() { val family = listOf( Person(\u0026#34;a\u0026#34;), Person(\u0026#34;b\u0026#34;) ) val deepCopiedFamily = family.map { member -\u0026gt; member.copy() } // 一人目の名前を変えちゃう  deepCopiedFamily.first().name = \u0026#34;c\u0026#34; println(\u0026#34;family = $family\u0026#34;) println(\u0026#34;copiedFamily = $deepCopiedFamily\u0026#34;) } family = [Person(name=a), Person(name=b)] copiedFamily = [Person(name=c), Person(name=b)] 一例でしかありませんが、この例では map()メソッドによって要素を逐一コピーしたものを新しく生成されるコレクションの要素に与えています。 インスタンスに対して copy()メソッドを実行すると、そのインスタンスの deep copy が返されます。 これを新しいコレクションの要素とすれば、各要素の deep copy で構成されたコレクションが得られます。\nプリミティブ型は例外 プリミティブ型については、to~によるコピーで別の値としてのコピーが作成されます(そもそもプリミティブ型に対して copy()メソッドは定義されていない)。\nfun primitiveCopy() { val list = listOf(0, 1) val copiedList = list.toMutableList() // コピーしたリストの要素をいじってみる  copiedList[0] = 2 println(\u0026#34;list = $list\u0026#34;) println(\u0026#34;copiedList = $copiedList\u0026#34;) } list = [0, 1] copiedList = [2, 1] 試しにやってみると、単に toList()によって(要素をいじりたいので実際は toMutableList()によって)作られたコピーの要素をいじってみても、元の要素に変更はないことがわかります。\ncopy メソッドでも shallow copy が作られる (2021/9/21 追記) data class の　copy() メソッドに関して訂正です。 deep copy が欲しければ data class の copy() メソッドを使えばよいと上で述べましたが、実際に生成されるのは shallow copy のため、状況によっては不適切です。\n\u0026ldquo;状況によっては\u0026quot;というのも、コピーしたい data class のプロパティがプリミティブ型のみであれば、実際は deep copy の生成とみなせますので問題は起こらないはずです。問題が起こりうるのは、下記のようにインスタンスをプロパティとして保持している場合です。\ndata class Container(val content: Content) data class Content(var id: Int) fun instanceProperty() { val content = Content(0) val container = Container(content) val copiedContainer = container.copy() copiedContainer.content.id = 1 println(\u0026#34;content in container = $container\u0026#34;) println(\u0026#34;content in copiedContainer = $copiedContainer\u0026#34;) } 実行結果は下記のようになり、 Container クラスのプロパティである content インスタンスは元の参照と同じものを持っているため、コピー先への変更がコピー元が保持している content にまで及んでいることがわかります。\ncontent in container = Container(content=Content(id=1)) content in copiedContainer = Container(content=Content(id=1)) こういったケースで deep copy が必要になる場合は Container クラスに自力で copy メソッドを実装して、プロパティのインスタンスも copy によってコピーするのが単純でしょうか…。\ndata class Container(val content: Content) { fun copy() = Container(content.copy()) // 手動コピー } data class Content(var id: Int) 上記のコードで一応の目的は果たせることになりますが、拡張性もメンテナンス性も最悪です。 Container クラスを拡張した場合は忘れずに独自実装の copy() メソッドも修正する必要があります(が、質の悪いことに修正を忘れてもコンパイルは通ってしまいます)。\n調べてみると、 deep copy を生成するためのライブラリも公開されているようです。\nコピーなんて単純だと思っていましたが、目的にあったコピーは意外と難しいものでした…。スマートなアイディアをお持ちの方、ぜひ筆者に教えてください。\n"},{"uri":"https://mtakamur.github.io/kotlin/struggled/","title":"ハマったこと","tags":[],"description":"","content":"思った通りにならなくて、解決に時間がかかってしまったことです。誰かの役に立つことを願って。\n コレクションの deep copy が欲しい  更新日: 2021/9/12\n data class copy() の対象  更新日: 2021/9/13\n"},{"uri":"https://mtakamur.github.io/kotlin/struggled/target_of_copy/","title":"data class copy() の対象","tags":[],"description":"","content":"更新日: 2021/9/13\nまとめ  data class のプロパティは、特に理由がない限りはプライマリコンストラクタ中で宣言したほうが良い プライマリコンストラクタ意外で定義したプロパティは、equals(), hashCode(), copy()メソッドの生成時に考慮されない   data class の copy()メソッドは primary constructor に基づく data class を作ると、Kotlin 側で自動的に下記の 5 つのメソッドを実装してくれ、私たちは特に気にしなくても便利にデータクラスを使えるのでした。\n equals(): プロパティの同一性を true / false の 2 値で返してくれるメソッド hashCode(): プロパティを基に一意なハッシュ値を生成してくれるメソッド toString(): インスタンスを文字列出力したときのフォーマット componentN(): N 番目のプロパティへのアクセサ copy(): 元のプロパティと同じ値を持った別のインスタンスを生成してくれるメソッド 今回は、copy() メソッドではいかなるプロパティも自動でコピーしてくれると思っていてハマったお話です。  結論として、copy() メソッドでコピーしてくれるのは data class の primary constructor で宣言されているプロパティのみです。データクラスの実装上、 コンストラクタ以外の部分でもプロパティを定義することができますが、それらは copy() メソッドの対象外になってしまうので注意が必要です。 このことは公式ドキュメントにも(分かりづらいですが)ちゃんと書いてありました。自動的に生成される 5 メソッドは、あくまでプライマリコンストラクタで宣言されたプロパティだけを対象として生成されるということですね。\n例えば下記のような実装をすると、isAdult は data class Human のプロパティではありますが、 copy() メソッドで値がコピーされません。\ndata class Human( val name: String, val age: Int, ){ var isAdult: Boolean = false // コンストラクタ外での定義  } fun notCopied() { val human = Human(name = \u0026#34;mtakamur\u0026#34;, age = 27) if (human.age \u0026gt;= 20) human.isAdult = true // プロパティを更新  val copiedHuman = human.copy() println(\u0026#34;human = $human, isAdult = ${human.isAdult}\u0026#34;) println(\u0026#34;copiedHuman = $copiedHuman, isAdult = ${copiedHuman.isAdult}\u0026#34;) }  human = Human(name=mtakamur, age=27), isAdult = true copiedHuman = Human(name=mtakamur, age=27), isAdult = false // 変えたはずなのに…。 isAdult の定義をちゃんとプライマリコンストラクタに移動してあげると、isAdult も copy() によって複製されるようになります。\nそもそもデータクラス(値の塊をパックする入れ物)という概念上、上記のような実装は避けるべきかもしれません。コンストラクタ以外の場所でプロパティを定義したい場合には下記のようにすると安全そうです。\ndata class ModifiedHuman( val name: String, val age: Int ) { val isAdult = age \u0026gt;= 20 } ポイントはコンストラクタ外のプロパティの値は、コンストラクタで宣言されている値のみに依存させるということです。 そうしておけば、copy() 時にもコンストラクタで宣言されている値を追いかけることができるようになります。\n"},{"uri":"https://mtakamur.github.io/kotlin/others/","title":"その他","tags":[],"description":"","content":"どこのジャンルに入れていいかわからなかった、けど知っておくと便利なことをつらつらと。\n Trailing commas  "},{"uri":"https://mtakamur.github.io/kotlin/","title":"Kotlin","tags":[],"description":"","content":"Android 開発の公式言語に。 Java と比べると安全で読みやすいコードが書きやすい印象。\n ハマったこと  思った通りにならなくて、解決に時間がかかってしまったことです。誰かの役に立つことを願って。\n その他  どこのジャンルに入れていいかわからなかった、けど知っておくと便利なことをつらつらと。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/","title":"忙しい人のための Effective Kotlin","tags":[],"description":"","content":"Effective なんちゃらシリーズの Kotlin 版。まだ日本語版が出版されていませんし、総ページ数 400 ページ余りとなかなかのボリュームなので、手を出しづらい方もいらっしゃるでしょう。 そんな忙しい方のために、要点だけをちょこちょこお届け。 なるべくセクションごとのまとめを心がけますが、執筆順不同です。誤訳も多分ありますので悪しからず。\n Part 1: Good code(良いコードとは?)  \n Part 2: Code design(コード設計)  \n Part 3: Efficiency(効率の良いコード)  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_1_limit_mutability/","title":"Item 1: Limit mutability(やたらと変更可能にしない)","tags":[],"description":"","content":"更新日: 2021/10/04\nまとめ  ちょっと詳しく インスタンスの状態を表すために変数を使うことはよくあるでしょう。 Kotlin では val と var によって変数定義を行えます。 val で定義された物は一度値が代入されるともう変更できない(immutable な)変数となり、一方 var によって定義された変数は何度でも値を変更できます(mutable)。\nこれだけ見ると何でもかんでも var にしておいて、必要な時に自由に書き換えられた方が便利に見えます。 ただし、テーマである\u0026quot;安全性\u0026quot;の観点から見ると、 var を用いることによるデメリットも見えてきます。\n コードの理解とデバッグが難しくなります  var 変数はコードの実行により変更され得るポイントとなるので、その状態遷移を追いかけることは難しくなります   コードの意味の推測が難しくなります  immutable な値であれば、コードの中で変更されることのない状態となるので意味が明らかです mutable な値は、いつ、何に、どんな理由で書き換えられるのかまで理解する必要が出てくるので、状態を追いかけるのが非常に難しくなります   正しく排他処理を実装する必要があります  色々なスレッドから値が変更され得るような状況では、同時に値を書き換えられないような実装(排他制御)が必要になります もちろん、immutable な変数ではそんなこと考える必要ありません。   状態の数だけ必要なテストが増えます  値が変更されるということは、変更されるパターンの数だけ必要なテストが増加することを意味します 一般に必要なテストの量は、状態の数に対して指数関数的に増加してゆきます。変更可能な箇所は少ないほうが良いでしょう   状態変化の通知が必要になる場合があります  ある一つの mutable 変数を複数のクラスが参照しているような状況では、\u0026ldquo;誰かが値を書き換えた\u0026quot;ということを他のクラスが知る必要がある場合があります    もちろん、全ての mutable な値がダメなわけではありません。 必要に応じて、正しく賢く mutable な値を使いましょう。\nKotlin の優れているところは、immutable で良い場合には簡単にそれが実現できるところです。 valにするだけ。\nLimiting mutability in Kotlin(変更可能箇所を減らす) Kotlin では、mutability、すなわち変更可能性を制限する仕組みが下記のようにいくつか用意されています。\n valによる変数宣言 読み取り専用コレクション データクラスの copy()メソッド  これらについてもうちょっと詳しく見て行きます。\nRead-only properties val(valで定義される読み取り専用変数) すでに何度か登場していますが、Kotlin ではvalによって変数宣言することで、読み取り専用の変数を作ることができます。 ただちょっと注意しなければならないのは、valで宣言したからと言って必ずしも不変であったり、Java などでいう final を意味するわけではないということです。 例えば、後ほど登場しますが、mutable なコレクションをvalで宣言しても、コレクションの要素の変更は問題なく行えてしまいます。\nval list = mutableListOf(1, 2, 3) // Mutable = 要素の変更が可能なコレクション list.add(4) // 問題なし 上の例では、valで宣言したにもかかわらず要素の変更が行えています。これは、valが意味するのは参照先が不変ということだからです。 val listが表しているのは、どこのコレクションかという情報だけなので、参照先のコレクションにいくら変更が加えられたとしてもval listとしては知ったことではありません。 したがって、valによる変数宣言で禁止されるのは下記のような変更です。\nval list = mutableListOf(1, 2, 3) list = mutableListOf(4, 5, 6) // エラー！ 上の例では、val listが指し示す先を、4, 5, 6 を要素とするまるっきり別のコレクションに変更しようとしているためエラーになります。\nここで紹介したルールを用いると、カスタム getter() もval変数として以下のような書き方ができることになります。\nvar firstName = \u0026#34;Alice\u0026#34; var familyName = \u0026#34;Cern\u0026#34; val fullName get() = \u0026#34;$firstName$familyName\u0026#34; fum main() { println(fullName) // Alice Cern  firstName = Atlas // firstNameはmutableな変数なので書き換えてもよい  println(fullName) // Atlas Cern } fullNameはval変数なはずなのに中身が変わっていますね。 これは、fullName(のカスタム getter)はあくまでfirstNameとfamilyNameから値を計算するということしか定義されていないので、firstNameやfamilyNameの中身がどう変更されようが気にしないということになります。\nこの動作からもう一つわかることとして、カスタム getter は呼び出されるたびに参照先の値を取得して都度計算して値を出力するということです。 便利だからと言って、あまりに重い計算をカスタム getter に定義してしまうと、単に変数を読んでいるだけに見えるのに非常に反応が遅いということも起こり得ます。\nというわけで、Kotlin におけるvalプロパティは、不変である(=final である)ことを常には意味しないので注意が必要です。\nSmart cast(スマートキャスト -null じゃないのはもう知ってるね？-) valの性質から、Kotlin では smart cast という仕組みが用意されています。 ここまでで触れられていませんが、Kotlin では基本的に変数は null にはなりません。 どうしても変数の状態として null が必要な場合には、?によって明示的にそれを示す必要があります。\nval name : String? = null // これは問題なし val name : String = null // nullかもって言っていないのでこれはダメ 上記のように、null かも?という変数には、その型に?を加えます。 Kotlin では、null かもしれないクラス(?付)と絶対に null ではないクラスは別々の型と考えます。 null は便利かつ厄介な代物で、変数が null かも?(= nullable)な場合には、その取扱いはかなり気を使う必要があります(一般に null な値に対して演算はできませんで、何かしらの演算を試みた段階でいわゆる\u0026quot;ぬるぽ(NullPointerException)\u0026ldquo;が発生してプログラムが継続できなくなります)。\nnullable な値を扱うときは、多くの場合例外的な処理が必要となるので、null かどうかを都度チェックする必要があります。これが面倒くさいし、コードも汚くなるのであまりやりたくありません。 そこで、前置きが長くなりましたが、Kotlin では Smart cast という仕組みがあります。 簡単に表現すると、一度 null ではないと分かったval変数は、それ以降 non-null な値として扱える仕組みです。\nval name: String = \u0026#34;Alice\u0026#34; val age : Int? = 0 fun main() { if (age != null){ println(\u0026#34;Name = $anme, age = $age\u0026#34;) ... val nextAge = age + 1 // 足し算なんかして大丈夫?  println(\u0026#34;Name = $name, age = $age\u0026#34;) } } if 節の中身だけ読むと怖いことをやっていますね。 null かもしれない値に対する足し算です。 万が一val ageが null だったら終わりです。 でもこの足し算が実行されている以上は絶対にそんなことはありません。if 節を実行する条件として、val ageが null でないことを課しているからです。 したがって、人間が読めばすぐにわかることですが、if 節の中でval ageが null ではあり得ないので、件の足し算は確実に安全に行えます。\n一方、先ほどの例とほとんど同じに見える次の例では、例の足し算は絶対に確実に安全といえるでしょうか?\nval name: String = \u0026#34;Alice\u0026#34; var age : Int? = 0 fun main() { if (age != null){ println(\u0026#34;Name = $anme, age = $age\u0026#34;) ... val nextAge = age + 1 // 足し算なんかして大丈夫...じゃないこともある  println(\u0026#34;Name = $name, age = $age\u0026#34;) } } これは安全とは言い切れません。なぜならvar ageは変更されうるからです。もし...の部分の処理でvar ageが null に変更されていた場合は、この足し算はやってはいけません。\nこれらの例からわかるように、 Smart cast はval変数は変更されないという前提の下での仕組みです。 nullable なvar変数に対しては Smart cast は機能しません(もちろんカスタム getter を備 f えた変数に対しても機能しない)。\n簡単のために上記のような例を出しましたが、実際のコーディングで Smart cast の恩恵を受けるのは、変数をメソッドにパラメータとして与える場面が多いかと思います。 もしも Smart cast がないと、呼び出すメソッドが non-null なパラメータしか受け付けない場合には、呼び出しのたびに non-null な変数にキャストしてから渡すという、本質的な処理ではないコードを書く必要が出てきます。 Smart cast があるおかげで、コードをきれいに保つことができるわけです。\nちなみに Smart cast という名前ですが、一度 null でないことを確認した以降は?がとれた(non-null な)型とみなす、ある種の型変換を意味しています。\nSeparation between mutable and read-only collections(変更可能なコレクションと不可能なコレクション) Kotlin では、要素の集合を上手に扱う手段としてコレクションが登場しています。 概念としては他言語での配列と同じです。\nすでにこれまでの例で登場していますが、コレクション(list, set, map)にも mutable なものと immutable なものが別々に用意されています(相互の変換は一応可能)。 Kotlin のコレクションは immutable なものをベースにしており、mutable なコレクションがそれを継承して setter を実装しているイメージです。\nKotlin でコレクションを扱うとき、やってはいけないことがあります。 それは immutable -\u0026gt; mutable (不変コレクションからコレクションへの)ダウンキャストです。\n 無理に書き換えると、そもそも immutable にした意味がない。チームで開発しているような状況では、\u0026ldquo;このコレクションは immutable なはず\u0026quot;という前提が崩れるので、思わぬバグを生む原因になる。 mutable とみなされても、実際に書き換えが行えるかどうかはプラットフォームの実装による(後述)  2 つめの理由についてもうちょっと詳しく説明します。例えば下記のコード例では実行結果はプラットフォームに依存します。\nval list = listOf(1, 2, 3) if (list is MutableList){ list.add(4) // ここでエラーになるかどうかはプラットフォームに依る } 上記がエラーになる環境として、JVM 環境があります。JVM 環境では、listOfによって生成されるのは Java のListインターフェースを実装しているArrays.ArrayListになります(これは add などの要素変更メソッドを実装していないことに注意してください)。 しかし、Listインターフェースには setter メソッド類も定義されているので、Kotlin の環境だと要素の編集機能も持っているとみなされてMutableList扱いになります。 したがって、実際には setter メソッド類の実装を持っていないArrays.ArrayListに対してaddが実行されることになってエラーになります。 Listインターフェース\nCopy in data classes (データクラスのコピーメソッド) Kotlin にはデータクラスという概念があります。 主にデータを(名前付きで)保持することを目的としたクラスですが、通常のクラス同様にメソッドを定義することもできます。\ndata class Person( val firstName : String, val familyName : String, val age : Int ) { fun getFullName() = firstName + familyName } data class では、通常のクラスと比較して以下の違いがあります。\n equals(), hashCode()の自動実装 copy()メソッドの実装(以下で紹介します)  上記の例では、人間一人に対して 1 インスタンスずつ生成するイメージでしょうか。 ところで、データクラスインスタンスを生成するときに、別のインスタンスの一部分のデータだけを変更すれば十分なことも頻繁にあります。 家族に対して子供を追加するときなどはその例だと思います(名前だけ違うけれども、苗字は一緒)。\nこのような場合、data class に備わっている copy()メソッドを使うことで、以下のように供インスタンスを作ることができます。\nval parent = Perosn(firstName = \u0026#34;m\u0026#34;, familyName = \u0026#34;t\u0026#34;, age = 27) val child = parent.copy(firstName = \u0026#34;n\u0026#34;, age = 0) 現実的にはちょっと気持ち悪い表現ではありますが、親をコピーして名前と年齢だけ変えて新しいインスタンスを作っています。\ncopy()メソッドがなぜこの節で登場するかというと、コピーの結果だけ見ると mutability の観点からはちょっと不思議なことが起きているからです。 コピーの結果を見ると、ひとまず parent のインスタンスのコピーを作ってしまって、firstName と age を書き換えたように見えないでしょうか?(プロパティはすべてvalなのに!)\nPerson クラスのプロパティは全部valなのに変更できるのか？という疑問がわくかもしれませんが、copy()メソッド内での変更(しているように見える部分)は、あくまで新しいインスタンスの初期化処理の一部分です。 コピー元から変更する必要のないプロパティについては、コピー元からそのまま引き継ぐような動作をします。 したがって、内容をちょっと変更したコピーを作るために、プロパティをvarにしたりする必要はないということになります。 プロパティを immutable に保ったままでこのような記述ができるので、とてもエレガントな手法ですね。\nDifferent kinds of mutation points(どこを可変にしようか？) 可変なコレクション(リスト)が必要になったとしましょう。 コレクションを変数化するときに、次の二つの書き方が思い浮かびます。\nval list1 = MutableList\u0026lt;Int\u0026gt; = mutableListOf() // 1.コレクションがmutableで、変数自体はimmutable var list2 = List\u0026lt;Int\u0026gt; = listOf() // 2.コレクションはimmutableで、変数自体がmutable 1.を使った場合、コレクション自体に要素を足し引きすることができます。\nlist1.add(1) 2.の場合、コレクションに add したりはできないので、要素を追加した新しいコレクションインスタンスでlist2を置き換える操作が必要になります。\nlist2 = list2 + 1 // 元のlist2と1を合わせた新しいListで置き換える この 2 つの例は、本文の言葉を借りれば mutation point (変更が生じうるポイント)が異なると言えます。 1.ではコレクション自体が mutation point、2. では変数そのものが mutation point になっています。 さて、どちらが優れているでしょうか？ 読みやすさという意味では 1.だと思います。なぜならほとんど人間の言語だからです。\nただし、マルチスレッドでこのコレクションの変更を行う場合では 2.の方が安全(な実装を行いやすい)です。 マルチスレッド処理では、複数のスレッドから同時に同じコレクションが変更されることを想定せねばなりません。 1.によるコレクションの変更を行う場合、実際に要素を書き換える処理は MutableList に任せることになります。 いかなる時も MutableList が適切なタイミングで処理を行ってくれるという保証はないので、潜在的に危険です。 一方、2.の実装を行っている場合、list2変数の変更タイミングさえきちんと synchronized にしておけば、マルチスレッドからの同時変更による問題は起きないことになります。\nもちろん、マルチスレッド処理においてどちらも安易な実装をすれば同時変更による問題を生じます。 実装 1.と 2.を比較したときに、mutation point が実装者側にある(=実装者が自由に制御できる)2.のパターンのほうが、安全な実装を行いやすいことになります。\n蛇足ですが、もちろん次のような実装はやるべきではありません。\nvar list3 = MutableList\u0026lt;Int\u0026gt; = mutableListOf() // コレクションの変更も変数の置き換えも両方できる mutation point を無意味に増やすのは避けましょう。\nDo not leak mutation points (mutation point は見えないように) Mutation point はよほどの理由がない限り、クラス外からは見えないようにするべきです。\nclass Contacts() { private val phoneNumbers = MutableList\u0026lt;String\u0026gt; = mutableListOf() fun getPhoneNumbers() = phoneNumbers } 上の例では、getPhoneNumbers()メソッドによって、登録されている電話番号のリストを取得できます。 それも mutable なリストとして。 ということで、getPhoneNumbers()が public である以上、誰でもいたずらで電話番号を書き換えることができてしまうわけです。 これは良くないですね。そもそもphoneNumbersを private にした意味がまるでありません。 対策としては、次の 2 点があげられます。\n phoneNumbersをデータクラス化して、外部からの要求に対しては常にcopy()メソッドの戻り値を渡す(defensive copy と呼ばれます) getPhoneNumbers()の戻り値の型をList\u0026lt;String\u0026gt;にアップキャストする  mutation point は外から直接見えないようにして、外部から好き勝手に変更を加えられないように注意しましょう。\n"},{"uri":"https://mtakamur.github.io/kotlin/others/trailing_commas/","title":"Trailing commas","tags":[],"description":"","content":"まとめ  Kotlin 1.4 以降ではコレクションやメソッド引数の最終要素に\u0026quot;,\u0026quot; (trailing comma) を残しておいてもコンパイルエラーになりません trailing comma があってもなくてもコードの動作は一切変わりません trailing comma をつけるようにしておくと、チーム開発するときのレビューがしやすくなります (コレクションやメソッドの引数に変更を加えても、追加削除した行だけが変更点として表示されるから)   Trailing comma (末尾のカンマ) コレクションの要素やメソッドのパラメータなど、同列の要素を複数個並べたいときは下記のようにカンマで区切って並べます。 この時、最後の要素の後には\u0026quot;,\u0026ldquo;を書かないのが一般的かと思います。 実際、Kotlin 1.4 より古いバージョンでは、余分なコンマを付けているとコンパイルエラーになります。\nval colors = listOf( \u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34; // \u0026lt;-ここにはカンマをつけていない  ) ところが Kotlin 1.4 以降では、最終要素の後ろにも\u0026rdquo;,\u0026ldquo;を残しておいて OK になりました。 この余分なカンマのことを trailing comma と呼びます。\nなにがうれしい？ trailing comma があってもなくてもコードの動作には一切影響ありません。\ntrailing comma が若干ありがたく感じるのは、チームで開発を進めて、お互いにコードをレビューしあうような状況でしょうか。 開発を進めていくと、既存のメソッドにパラメータを追加したり、逆に削除したくなることはよくあるかと思いますが、この時に \u0026ldquo;これは最後の要素だからカンマを消して…\u0026rdquo; とか考える必要がなくなります。 カンマの追加/削除が本質的な変更点ではありえないでしょうから、余計な変更を加える必要がなくなり、コードレビューをするときも、本質的な変更点だけに集中することができるようになります。\n配列やパラメータの順番だけを変更するときも幾分やりやすくなっているかと思います。 カンマのあるなしは気にせず、配列の行丸ごとの置換で OK になります。公式ドキュメントにもその旨記述があります。 多分ありがたいのはこれくらいでしょうか。\nコンマ？カンマ？ 今さらコンマとカンマで表記ゆれがあることに気づきました…。 アドバイスとアドヴァイスみたいな。 カタカナで発音を表現しようとしている時点で間違ってますから、どっちでもいいですよね。\n"},{"uri":"https://mtakamur.github.io/","title":"Pi fruit","tags":[],"description":"","content":"Pi fruit  Kotlin  Android 開発の公式言語に。 Java と比べると安全で読みやすいコードが書きやすい印象。\n 忙しい人のための Effective Kotlin  Effective なんちゃらシリーズの Kotlin 版。まだ日本語版が出版されていませんし、総ページ数 400 ページ余りとなかなかのボリュームなので、手を出しづらい方もいらっしゃるでしょう。 そんな忙しい方のために、要点だけをちょこちょこお届け。 なるべくセクションごとのまとめを心がけますが、執筆順不同です。誤訳も多分ありますので悪しからず。\n "},{"uri":"https://mtakamur.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]