[{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/","title":"Chapter 1: Safety(安全なコード)","tags":[],"description":"","content":"プロジェクトに Java でも C++でもなく Kotlin を用いるのでしょう。 その最大の理由は、Kotlin によるコーディングがもたらしてくれる\u0026quot;安全性\u0026quot;です。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/","title":"Part 1: Good code(良いコードとは?)","tags":[],"description":"","content":" Chapter 1: Safety(安全なコード)  プロジェクトに Java でも C++でもなく Kotlin を用いるのでしょう。 その最大の理由は、Kotlin によるコーディングがもたらしてくれる\u0026quot;安全性\u0026quot;です。\n Chapter 2: Readability(読みやすいコード)  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/","title":"Item 19: do not repeat knowledge","tags":[],"description":"","content":"更新日: 2021/10/04\nこの節の内容は、言語にとらわれず意識しておくべき基礎的な原則です。\n まとめ  コーディングしている中で、コピペが必要になったときはちょっと立ち止まろう。同じことを二度書く必要はきっとないはず。 すべての変数やメソッドは変更されうる、という前提の下でコーディングしよう。 つまり無意味にコピペがあると、次の 2 つの理由で痛い目を見ます。  一つを変更したら全部変えなきゃ。面倒くさくない？ コピペしたところは一切もれなく(チームのほかの人がコピペしたものも含めて)把握している？たった一つでも見逃しているとその時点でバク発生！   ただし、何でもかんでも共通化してコピペを避けるべきというわけではない。共通化すべきかどうかの判断基準の一つは、片方を変更するときにもれなくもう片方も変更する必要があるか。 もしも別々に変更する可能性があるのであれば、それは共通化すべきでない。 なぜなら姿形はまったく同じでも意味の違うものであるから。 共通化にせよ分離にせよ、どちらかに極端に偏るといずれも良くない。 十分に訓練して、程よいバランスを保てるようにしよう。   ちょっと詳しく コーディングの原則としてよく知られている(しかし実践は実は難しい)\u0026ldquo;DRY (= Don\u0026rsquo;t Repeat Yourself) 原則\u0026quot;というものがあります。 平たく言えば、\u0026ldquo;同じ情報は 2 度書くのは良くないよ\u0026quot;という原則です。 まとめにある通り、1 つのプロジェクトの中でコピペをするということは、 どこかと同じ変数なりアルゴリズムなりを 2 度以上書いているということになります。 これは少なくとも下記の理由で避けるべきです。\n 単純に無駄だから。共通で使えるようにすればコーディングする時間もファイルサイズも 2 つ分は必要ないはずですよね。 1 つを変更しなくてはいけない時に死ぬほど面倒くさい。 なぜならコピペしたものを全部もれなく変更しなくてはいけないから。 DRY 原則に反したコーディングを、WET(= We Enjoy Typing, Waste Everyone\u0026rsquo;s Time, or Write Everything Twice) アンチパターンと呼んだりします。 DRY に対して WET、いい感じで対になってますね。  Knowledge -情報/知識- この節で言う\u0026quot;Knowledge\u0026quot;としては主に下記の 2 つに焦点を当てています。\nロジック: コードの振る舞いを記述するもの 共通アルゴリズム: ロジックを実現するための下回り計算 上記 2 つの違いはぱっと見わかりづらいものですが、ロジックはアプリケーションの要求に応じていつでも変わりうるもので、 それに対してアルゴリズムは、ロジックが変更されても基本的には変更されることのない仕組みの部分をさしています。\nEverything can change -すべてのものは変わりうる- ということで、世の中のありとあらゆるものは変化し続けます。 ソフトウェアについては特に変化が顕著で、長年一切の変化がないものはほとんど見つけることはできないでしょう。\n従って、自分が書いているコードはいつか必ず変更されるという前提に立っているべきなのです。 そして、いざ既存のコードを変更しようとしたとき、最も大きな障害となるのがロジックやデータの繰り返しです。 同じ意図で書かれた同じロジックやデータは、変更しようとしたときにもれなく更新する必要があります。\n 単純に時間と労力の無駄 どんなに気を付けていても変更漏れのリスクを避けられない  という観点で、繰り返しは避けるべきといえます。 コーディングの領域では、インターフェースなどの抽象化によってある程度変更しやすい(無駄な繰り返しを避けた)実装を行うことができます。\nWhen should we allow code repeatation? -コードを繰り返してもよいのはどんな時？- 一見同じコードが複数の場所に書かれていても問題がないケースもあります。 見た目は違っても意図が違う場合です。 一方を変更したときに他方も必ず変更する必要があるかが、コードの繰り返しに問題があるかどうかを判断する基準の一つとして有効です。 もし、独立に変更することが考えられるのであれば、一見同じコードが何か所かに書かれていても常には問題になりません。\nSingle responsibility principle -違う目的で使いまわさない- 目的が違う変数やメソッドは、(仮に見た目が全く同じであっても)一つにまとめるべきではありません。 何故なら、それらは今の見た目は同じであっても将来的に独立して変更される可能性があるからです。 言い換えると、本来別々であるべきものを、たまたま形が似ているからと言って定義を一緒にしてしまっているということになります。 もしこれらを一つのメソッドや変数にまとめてしまっていると、変更が生じたときには、変更がそれを利用しているすべてに及んでしまい、 思わぬバグを生むことになります。\n一つのクラス、変数、メソッドに一つの役割だけを持たせる (= Single responsibility prinsiple)ようにすべきです。\nサイト筆者の勝手な見解 ここまで\u0026quot;同じことは二度書くな\u0026quot;ということと、\u0026ldquo;必要以上に共通化しすぎると痛い目を見る\u0026quot;と両極端なことを述べてきました。 ここからはサイトの筆者の解釈ですが、コーディングをする際はやはり基本的には\u0026quot;同じことは二度書くな\u0026quot;の精神でいたほうが良いと思います。\nコードを共通化するためには、値や処理に対して変数やメソッド名として名前を付けてあげることとなります。 変数やメソッドに名前を付けるときに、名前の候補がいろいろと考えられて決めきれないときや、やたらと長い名前になってしまうときはまだ名づけるべき単位に分離しきれていないサインかもしれません。 ちょっと立ち止まって、変数やメソッド名を分離できないか考えるとよいかもしれませんね。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_1/chapter_2/","title":"Chapter 2: Readability(読みやすいコード)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/","title":"Part 2: Code design(コード設計)","tags":[],"description":"","content":" Chapter 3: Reusability(再利用性)  コードは再利用しやすいように書こうね、という話。\n Chapter 4: Abstraction design(抽象化設計)  \n Chapter 5: Object creation(インスタンス生成)  \n Chapter 6: Class design(クラス設計)  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/","title":"Part 3: Efficiency(効率の良いコード)","tags":[],"description":"","content":" Make it cheap  \n Efficient collection processing  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/","title":"Chapter 3: Reusability(再利用性)","tags":[],"description":"","content":"コードは再利用しやすいように書こうね、という話。\n Item 19: do not repeat knowledge  \n"},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_4/","title":"Chapter 4: Abstraction design(抽象化設計)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_5/","title":"Chapter 5: Object creation(インスタンス生成)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_2/chapter_6/","title":"Chapter 6: Class design(クラス設計)","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/chapter_7/","title":"Make it cheap","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/effective_kotlin/part_3/chapter_8/","title":"Efficient collection processing","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/","title":"コレクションの deep copy が欲しい","tags":[],"description":"","content":"更新日: 2021/9/12\nまとめ  toList, toSet, toMap などの、コレクションの変換メソッドで得られるのは\u0026quot;浅いコピー\u0026quot; (Shallow copy) コレクションそのものは変換元とは別インスタンスなるが、プリミティブ型以外の要素は参照のコピーなので、目的に合ったコピーになっているか注意が必要 data class の copy()メソッドによるコピーも、実際は shallow copy。プリミティブ型以外のプロパティについては元のインスタンスと同じ参照を持つ Kotlin 組み込みの実装だけによって deep copy を作ることは現状できない。クラスごとに deep copy 用のメソッドを自力で実装するのが単純。   インスタンスのコピー toList, toSet など、コレクションを変換、コピーすることができるメソッドが Kotlin には用意されています。この時、コレクションの要素も deep copy されると思い込んではまったお話。\n値やインスタンスの集合であるコレクション(List, Set, Map など)を丸ごとコピーしたい場合は、下記のように toList, toSet, toMap など、目的の型への変換メソッドを使うことでコピーが行えます。 to~はコレクションの変換メソッドとして紹介されることが多いですが、変換元の型と同じ型への変換メソッドを使うと、中身が同じだけれども別インスタンスとしてのコレクション(コピー)を得ることができます。 ただし、プリミティブ型以外の要素は、 shallow copy が作られるだけで、参照先は変わりません。\n下記を例にとってみます。 Person クラスを要素に持つ List を、 toList() メソッドによってコピーしています。生成されたコピーに対して、一つ目の要素の値を書き換えてみます。\ndata class Person( var name: String ) fun shallowCopy() { val family = listOf( Person(\u0026#34;a\u0026#34;), Person(\u0026#34;b\u0026#34;) ) val shallowCopiedFamily = family.toList() // 一人目の名前を変えちゃう  shallowCopiedFamily.first().name = \u0026#34;c\u0026#34; println(\u0026#34;family = $family\u0026#34;) println(\u0026#34;copiedFamily = $shallowCopiedFamily\u0026#34;) } 要素を書き換えた後のそれぞれの List を出力してみると下記のようになります。 これは、toList()によるコピーが shallow copy だからです。 生成されたリスト自体は元のインスタンスと別物ですが、中に含まれるインスタンスは下図のように同じ場所を参照しています。\nfamily = [Person(name=c), Person(name=b)] copiedFamily = [Person(name=c), Person(name=b)] プリミティブ型以外の要素を持つコレクションをディープコピーしたい場合は、下記のように一工夫必要となります。\nfun deepCopy() { val family = listOf( Person(\u0026#34;a\u0026#34;), Person(\u0026#34;b\u0026#34;) ) val deepCopiedFamily = family.map { member -\u0026gt; member.copy() } // 一人目の名前を変えちゃう  deepCopiedFamily.first().name = \u0026#34;c\u0026#34; println(\u0026#34;family = $family\u0026#34;) println(\u0026#34;copiedFamily = $deepCopiedFamily\u0026#34;) } family = [Person(name=a), Person(name=b)] copiedFamily = [Person(name=c), Person(name=b)] 一例でしかありませんが、この例では map()メソッドによって要素を逐一コピーしたものを新しく生成されるコレクションの要素に与えています。 インスタンスに対して copy()メソッドを実行すると、そのインスタンスの deep copy が返されます。 これを新しいコレクションの要素とすれば、各要素の deep copy で構成されたコレクションが得られます。\nプリミティブ型は例外 プリミティブ型については、to~によるコピーで別の値としてのコピーが作成されます(そもそもプリミティブ型に対して copy()メソッドは定義されていない)。\nfun primitiveCopy() { val list = listOf(0, 1) val copiedList = list.toMutableList() // コピーしたリストの要素をいじってみる  copiedList[0] = 2 println(\u0026#34;list = $list\u0026#34;) println(\u0026#34;copiedList = $copiedList\u0026#34;) } list = [0, 1] copiedList = [2, 1] 試しにやってみると、単に toList()によって(要素をいじりたいので実際は toMutableList()によって)作られたコピーの要素をいじってみても、元の要素に変更はないことがわかります。\ncopy メソッドでも shallow copy が作られる (2021/9/21 追記) data class の　copy() メソッドに関して訂正です。 deep copy が欲しければ data class の copy() メソッドを使えばよいと上で述べましたが、実際に生成されるのは shallow copy のため、状況によっては不適切です。\n\u0026ldquo;状況によっては\u0026quot;というのも、コピーしたい data class のプロパティがプリミティブ型のみであれば、実際は deep copy の生成とみなせますので問題は起こらないはずです。問題が起こりうるのは、下記のようにインスタンスをプロパティとして保持している場合です。\ndata class Container(val content: Content) data class Content(var id: Int) fun instanceProperty() { val content = Content(0) val container = Container(content) val copiedContainer = container.copy() copiedContainer.content.id = 1 println(\u0026#34;content in container = $container\u0026#34;) println(\u0026#34;content in copiedContainer = $copiedContainer\u0026#34;) } 実行結果は下記のようになり、 Container クラスのプロパティである content インスタンスは元の参照と同じものを持っているため、コピー先への変更がコピー元が保持している content にまで及んでいることがわかります。\ncontent in container = Container(content=Content(id=1)) content in copiedContainer = Container(content=Content(id=1)) こういったケースで deep copy が必要になる場合は Container クラスに自力で copy メソッドを実装して、プロパティのインスタンスも copy によってコピーするのが単純でしょうか…。\ndata class Container(val content: Content) { fun copy() = Container(content.copy()) // 手動コピー } data class Content(var id: Int) 上記のコードで一応の目的は果たせることになりますが、拡張性もメンテナンス性も最悪です。 Container クラスを拡張した場合は忘れずに独自実装の copy() メソッドも修正する必要があります(が、質の悪いことに修正を忘れてもコンパイルは通ってしまいます)。\n調べてみると、 deep copy を生成するためのライブラリも公開されているようです。\nコピーなんて単純だと思っていましたが、目的にあったコピーは意外と難しいものでした…。スマートなアイディアをお持ちの方、ぜひ筆者に教えてください。\n"},{"uri":"https://mtakamur.github.io/kotlin/struggled/","title":"ハマったこと","tags":[],"description":"","content":"思った通りにならなくて、解決に時間がかかってしまったことです。誰かの役に立つことを願って。\n コレクションの deep copy が欲しい  更新日: 2021/9/12\n data class copy() の対象  更新日: 2021/9/13\n"},{"uri":"https://mtakamur.github.io/kotlin/struggled/target_of_copy/","title":"data class copy() の対象","tags":[],"description":"","content":"更新日: 2021/9/13\nまとめ  data class のプロパティは、特に理由がない限りはプライマリコンストラクタ中で宣言したほうが良い プライマリコンストラクタ意外で定義したプロパティは、equals(), hashCode(), copy()メソッドの生成時に考慮されない   data class の copy()メソッドは primary constructor に基づく data class を作ると、Kotlin 側で自動的に下記の 5 つのメソッドを実装してくれ、私たちは特に気にしなくても便利にデータクラスを使えるのでした。\n equals(): プロパティの同一性を true / false の 2 値で返してくれるメソッド hashCode(): プロパティを基に一意なハッシュ値を生成してくれるメソッド toString(): インスタンスを文字列出力したときのフォーマット componentN(): N 番目のプロパティへのアクセサ copy(): 元のプロパティと同じ値を持った別のインスタンスを生成してくれるメソッド 今回は、copy() メソッドではいかなるプロパティも自動でコピーしてくれると思っていてハマったお話です。  結論として、copy() メソッドでコピーしてくれるのは data class の primary constructor で宣言されているプロパティのみです。データクラスの実装上、 コンストラクタ以外の部分でもプロパティを定義することができますが、それらは copy() メソッドの対象外になってしまうので注意が必要です。 このことは公式ドキュメントにも(分かりづらいですが)ちゃんと書いてありました。自動的に生成される 5 メソッドは、あくまでプライマリコンストラクタで宣言されたプロパティだけを対象として生成されるということですね。\n例えば下記のような実装をすると、isAdult は data class Human のプロパティではありますが、 copy() メソッドで値がコピーされません。\ndata class Human( val name: String, val age: Int, ){ var isAdult: Boolean = false // コンストラクタ外での定義  } fun notCopied() { val human = Human(name = \u0026#34;mtakamur\u0026#34;, age = 27) if (human.age \u0026gt;= 20) human.isAdult = true // プロパティを更新  val copiedHuman = human.copy() println(\u0026#34;human = $human, isAdult = ${human.isAdult}\u0026#34;) println(\u0026#34;copiedHuman = $copiedHuman, isAdult = ${copiedHuman.isAdult}\u0026#34;) }  human = Human(name=mtakamur, age=27), isAdult = true copiedHuman = Human(name=mtakamur, age=27), isAdult = false // 変えたはずなのに…。 isAdult の定義をちゃんとプライマリコンストラクタに移動してあげると、isAdult も copy() によって複製されるようになります。\nそもそもデータクラス(値の塊をパックする入れ物)という概念上、上記のような実装は避けるべきかもしれません。コンストラクタ以外の場所でプロパティを定義したい場合には下記のようにすると安全そうです。\ndata class ModifiedHuman( val name: String, val age: Int ) { val isAdult = age \u0026gt;= 20 } ポイントはコンストラクタ外のプロパティの値は、コンストラクタで宣言されている値のみに依存させるということです。 そうしておけば、copy() 時にもコンストラクタで宣言されている値を追いかけることができるようになります。\n"},{"uri":"https://mtakamur.github.io/kotlin/others/","title":"その他","tags":[],"description":"","content":"どこのジャンルに入れていいかわからなかった、けど知っておくと便利なことをつらつらと。\n Trailing commas  "},{"uri":"https://mtakamur.github.io/kotlin/","title":"Kotlin","tags":[],"description":"","content":"Android 開発の公式言語に。 Java と比べると安全で読みやすいコードが書きやすい印象。\n ハマったこと  思った通りにならなくて、解決に時間がかかってしまったことです。誰かの役に立つことを願って。\n その他  どこのジャンルに入れていいかわからなかった、けど知っておくと便利なことをつらつらと。\n"},{"uri":"https://mtakamur.github.io/effective_kotlin/","title":"忙しい人のための Effective Kotlin","tags":[],"description":"","content":"Effective なんちゃらシリーズの Kotlin 版。まだ日本語版が出版されていませんし、総ページ数 400 ページ余りとなかなかのボリュームなので、手を出しづらい方もいらっしゃるでしょう。 そんな忙しい方のために、要点だけをちょこちょこお届け。 なるべくセクションごとのまとめを心がけますが、執筆順不同です。誤訳も多分ありますので悪しからず。\n Part 1: Good code(良いコードとは?)  \n Part 2: Code design(コード設計)  \n Part 3: Efficiency(効率の良いコード)  \n"},{"uri":"https://mtakamur.github.io/kotlin/others/trailing_commas/","title":"Trailing commas","tags":[],"description":"","content":"まとめ  Kotlin 1.4 以降ではコレクションやメソッド引数の最終要素に\u0026quot;,\u0026quot; (trailing comma) を残しておいてもコンパイルエラーになりません trailing comma があってもなくてもコードの動作は一切変わりません trailing comma をつけるようにしておくと、チーム開発するときのレビューがしやすくなります (コレクションやメソッドの引数に変更を加えても、追加削除した行だけが変更点として表示されるから)   Trailing comma (末尾のカンマ) コレクションの要素やメソッドのパラメータなど、同列の要素を複数個並べたいときは下記のようにカンマで区切って並べます。 この時、最後の要素の後には\u0026quot;,\u0026ldquo;を書かないのが一般的かと思います。 実際、Kotlin 1.4 より古いバージョンでは、余分なコンマを付けているとコンパイルエラーになります。\nval colors = listOf( \u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34; // \u0026lt;-ここにはカンマをつけていない  ) ところが Kotlin 1.4 以降では、最終要素の後ろにも\u0026rdquo;,\u0026ldquo;を残しておいて OK になりました。 この余分なカンマのことを trailing comma と呼びます。\nなにがうれしい？ trailing comma があってもなくてもコードの動作には一切影響ありません。\ntrailing comma が若干ありがたく感じるのは、チームで開発を進めて、お互いにコードをレビューしあうような状況でしょうか。 開発を進めていくと、既存のメソッドにパラメータを追加したり、逆に削除したくなることはよくあるかと思いますが、この時に \u0026ldquo;これは最後の要素だからカンマを消して…\u0026rdquo; とか考える必要がなくなります。 カンマの追加/削除が本質的な変更点ではありえないでしょうから、余計な変更を加える必要がなくなり、コードレビューをするときも、本質的な変更点だけに集中することができるようになります。\n配列やパラメータの順番だけを変更するときも幾分やりやすくなっているかと思います。 カンマのあるなしは気にせず、配列の行丸ごとの置換で OK になります。公式ドキュメントにもその旨記述があります。 多分ありがたいのはこれくらいでしょうか。\nコンマ？カンマ？ 今さらコンマとカンマで表記ゆれがあることに気づきました…。 アドバイスとアドヴァイスみたいな。 カタカナで発音を表現しようとしている時点で間違ってますから、どっちでもいいですよね。\n"},{"uri":"https://mtakamur.github.io/","title":"Pi fruit","tags":[],"description":"","content":"Pi fruit  Kotlin  Android 開発の公式言語に。 Java と比べると安全で読みやすいコードが書きやすい印象。\n 忙しい人のための Effective Kotlin  Effective なんちゃらシリーズの Kotlin 版。まだ日本語版が出版されていませんし、総ページ数 400 ページ余りとなかなかのボリュームなので、手を出しづらい方もいらっしゃるでしょう。 そんな忙しい方のために、要点だけをちょこちょこお届け。 なるべくセクションごとのまとめを心がけますが、執筆順不同です。誤訳も多分ありますので悪しからず。\n "},{"uri":"https://mtakamur.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://mtakamur.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]