<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ハマったこと on Pi fruit</title><link>https://mtakamur.github.io/kotlin/struggled/</link><description>Recent content in ハマったこと on Pi fruit</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 30 Oct 2021 11:43:06 +0900</lastBuildDate><atom:link href="https://mtakamur.github.io/kotlin/struggled/index.xml" rel="self" type="application/rss+xml"/><item><title>コレクションの deep copy が欲しい</title><link>https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/</link><pubDate>Sat, 30 Oct 2021 11:46:28 +0900</pubDate><guid>https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/</guid><description>更新日: 2021/9/12
まとめ toList, toSet, toMap などの、コレクションの変換メソッドで得られるのは&amp;quot;浅いコピー&amp;quot; (Shallow copy) コレクションそのものは変換元とは別インスタンスなるが、プリミティブ型以外の要素は参照のコピーなので、目的に合ったコピーになっているか注意が必要 data class の copy()メソッドによるコピーも、実際は shallow copy。プリミティブ型以外のプロパティについては元のインスタンスと同じ参照を持つ Kotlin 組み込みの実装だけによって deep copy を作ることは現状できない。クラスごとに deep copy 用のメソッドを自力で実装するのが単純。 インスタンスのコピー toList, toSet など、コレクションを変換、コピーすることができるメソッドが Kotlin には用意されています。この時、コレクションの要素も deep copy されると思い込んではまったお話。
値やインスタンスの集合であるコレクション(List, Set, Map など)を丸ごとコピーしたい場合は、下記のように toList, toSet, toMap など、目的の型への変換メソッドを使うことでコピーが行えます。 to~はコレクションの変換メソッドとして紹介されることが多いですが、変換元の型と同じ型への変換メソッドを使うと、中身が同じだけれども別インスタンスとしてのコレクション(コピー)を得ることができます。 ただし、プリミティブ型以外の要素は、 shallow copy が作られるだけで、参照先は変わりません。
下記を例にとってみます。 Person クラスを要素に持つ List を、 toList() メソッドによってコピーしています。生成されたコピーに対して、一つ目の要素の値を書き換えてみます。
data class Person( var name: String ) fun shallowCopy() { val family = listOf( Person(&amp;#34;a&amp;#34;), Person(&amp;#34;b&amp;#34;) ) val shallowCopiedFamily = family.</description></item><item><title>data class copy() の対象</title><link>https://mtakamur.github.io/kotlin/struggled/target_of_copy/</link><pubDate>Sat, 30 Oct 2021 11:46:57 +0900</pubDate><guid>https://mtakamur.github.io/kotlin/struggled/target_of_copy/</guid><description>更新日: 2021/9/13
まとめ data class のプロパティは、特に理由がない限りはプライマリコンストラクタ中で宣言したほうが良い プライマリコンストラクタ意外で定義したプロパティは、equals(), hashCode(), copy()メソッドの生成時に考慮されない data class の copy()メソッドは primary constructor に基づく data class を作ると、Kotlin 側で自動的に下記の 5 つのメソッドを実装してくれ、私たちは特に気にしなくても便利にデータクラスを使えるのでした。
equals(): プロパティの同一性を true / false の 2 値で返してくれるメソッド hashCode(): プロパティを基に一意なハッシュ値を生成してくれるメソッド toString(): インスタンスを文字列出力したときのフォーマット componentN(): N 番目のプロパティへのアクセサ copy(): 元のプロパティと同じ値を持った別のインスタンスを生成してくれるメソッド 今回は、copy() メソッドではいかなるプロパティも自動でコピーしてくれると思っていてハマったお話です。 結論として、copy() メソッドでコピーしてくれるのは data class の primary constructor で宣言されているプロパティのみです。データクラスの実装上、 コンストラクタ以外の部分でもプロパティを定義することができますが、それらは copy() メソッドの対象外になってしまうので注意が必要です。 このことは公式ドキュメントにも(分かりづらいですが)ちゃんと書いてありました。自動的に生成される 5 メソッドは、あくまでプライマリコンストラクタで宣言されたプロパティだけを対象として生成されるということですね。
例えば下記のような実装をすると、isAdult は data class Human のプロパティではありますが、 copy() メソッドで値がコピーされません。
data class Human( val name: String, val age: Int, ){ var isAdult: Boolean = false // コンストラクタ外での定義 } fun notCopied() { val human = Human(name = &amp;#34;mtakamur&amp;#34;, age = 27) if (human.</description></item></channel></rss>