<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.85.0"><meta name=description content="Simple notes for software engineering"><meta name=author content="mtakamur"><link rel=icon href=https://mtakamur.github.io/images/favicon.png type=image/png><title>Item 1: Limit mutability(やたらと変更可能にしない) - Pi fruit</title><link href=https://mtakamur.github.io/css/nucleus.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/fontawesome-all.min.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/hybrid.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/featherlight.min.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/perfect-scrollbar.min.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/auto-complete.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/atom-one-dark-reasonable.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/theme.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/tabs.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/hugo-theme.css?1660402441 rel=stylesheet><link href=https://mtakamur.github.io/css/theme-blue.css?1660402441 rel=stylesheet><script src=https://mtakamur.github.io/js/jquery-3.3.1.min.js?1660402441></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}</style></head><body data-url=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_1_limit_mutability/><nav id=sidebar><div id=header-wrapper><div id=header><a id=logo href=https://mtakamur.github.io/><img src=https://mtakamur.github.io/images/logo-gray.svg><br>Pi Fruit</a></div><div class=searchbox><label for=search-by><i class="fas fa-search"></i></label>
<input data-search-input id=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script type=text/javascript src=https://mtakamur.github.io/js/lunr.min.js?1660402441></script><script type=text/javascript src=https://mtakamur.github.io/js/auto-complete.js?1660402441></script><script type=text/javascript>var baseurl="https://mtakamur.github.io/"</script><script type=text/javascript src=https://mtakamur.github.io/js/search.js?1660402441></script></div><section id=homelinks><ul><li><a class=padding href=https://mtakamur.github.io/><i class="fas fa-home"></i> Home</a></li></ul></section><div class=highlightable><ul class=topics><li data-nav-id=/dart/ title=Dart class=dd-item><a href=https://mtakamur.github.io/dart/>Dart</a><ul><li data-nav-id=/dart/setup_environment/ title=Dart開発環境のセットアップ class=dd-item><a href=https://mtakamur.github.io/dart/setup_environment/>Dart開発環境のセットアップ</a></li><li data-nav-id=/dart/basis_on_function/ title=関数の基礎 class=dd-item><a href=https://mtakamur.github.io/dart/basis_on_function/>関数の基礎</a></li><li data-nav-id=/dart/variable_declaration/ title=変数の宣言 class=dd-item><a href=https://mtakamur.github.io/dart/variable_declaration/>変数の宣言</a></li><li data-nav-id=/dart/collection/ title=コレクション class=dd-item><a href=https://mtakamur.github.io/dart/collection/>コレクション</a></li><li data-nav-id=/dart/function-advanced/ title=関数 class=dd-item><a href=https://mtakamur.github.io/dart/function-advanced/>関数</a></li></ul></li><li data-nav-id=/flutter/ title=Flutter class=dd-item><a href=https://mtakamur.github.io/flutter/>Flutter</a><ul><li data-nav-id=/flutter/setup_flutter_sdk/ title="Flutter SDKのセットアップ" class=dd-item><a href=https://mtakamur.github.io/flutter/setup_flutter_sdk/>Flutter SDKのセットアップ</a></li></ul></li><li data-nav-id=/kotlin/ title=Kotlin class=dd-item><a href=https://mtakamur.github.io/kotlin/>Kotlin</a><ul><li data-nav-id=/kotlin/struggled/ title=ハマったこと class=dd-item><a href=https://mtakamur.github.io/kotlin/struggled/>ハマったこと</a><ul><li data-nav-id=/kotlin/struggled/collection_deep_copy/ title="コレクションの deep copy が欲しい" class=dd-item><a href=https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/>コレクションの deep copy が欲しい</a></li><li data-nav-id=/kotlin/struggled/target_of_copy/ title="data class copy() の対象" class=dd-item><a href=https://mtakamur.github.io/kotlin/struggled/target_of_copy/>data class copy() の対象</a></li></ul></li><li data-nav-id=/kotlin/others/ title=その他 class=dd-item><a href=https://mtakamur.github.io/kotlin/others/>その他</a><ul><li data-nav-id=/kotlin/others/trailing_commas/ title="Trailing commas" class=dd-item><a href=https://mtakamur.github.io/kotlin/others/trailing_commas/>Trailing commas</a></li></ul></li></ul></li><li data-nav-id=/effective_kotlin/ title="忙しい人のための Effective Kotlin" class="dd-item
parent"><a href=https://mtakamur.github.io/effective_kotlin/>忙しい人のための Effective Kotlin</a><ul><li data-nav-id=/effective_kotlin/part_1/ title="Part 1: Good code(良いコードとは?)" class="dd-item
parent"><a href=https://mtakamur.github.io/effective_kotlin/part_1/>Part 1: Good code</a><ul><li data-nav-id=/effective_kotlin/part_1/chapter_1/ title="Chapter 1: Safety(安全なコード)" class="dd-item
parent"><a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/>Chapter 1: Safety</a><ul><li data-nav-id=/effective_kotlin/part_1/chapter_1/item_1_limit_mutability/ title="Item 1: Limit mutability(やたらと変更可能にしない)" class="dd-item active"><a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_1_limit_mutability/>Item 1: Limit mutability(やたらと変更可能にしない)</a></li><li data-nav-id=/effective_kotlin/part_1/chapter_1/item_2_minimize_the_scope_of_variables/ title="Item 2: Minimize the scope of variables(変数のスコープは最小化する)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_2_minimize_the_scope_of_variables/>Item 2: Minimize the scope of variables(変数のスコープは最小化する)</a></li></ul></li><li data-nav-id=/effective_kotlin/part_1/chapter_2/ title="Chapter 2: Readability(読みやすいコード)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_2/>Chapter 2: Readability</a></li></ul></li><li data-nav-id=/effective_kotlin/part_2/ title="Part 2: Code design(コード設計)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/>Part 2: Code design</a><ul><li data-nav-id=/effective_kotlin/part_2/chapter_3/ title="Chapter 3: Reusability(再利用性)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/>Chapter 3: Reusability</a><ul><li data-nav-id=/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/ title="Item 19: do not repeat knowledge" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/>Item 19: do not repeat knowledge</a></li></ul></li><li data-nav-id=/effective_kotlin/part_2/chapter_4/ title="Chapter 4: Abstraction design(抽象化設計)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_4/>Chapter 4: Abstraction design</a></li><li data-nav-id=/effective_kotlin/part_2/chapter_5/ title="Chapter 5: Object creation(インスタンス生成)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_5/>Chapter 5: Object creation</a></li><li data-nav-id=/effective_kotlin/part_2/chapter_6/ title="Chapter 6: Class design(クラス設計)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_6/>Chapter 6: Class design</a></li></ul></li><li data-nav-id=/effective_kotlin/part_3/ title="Part 3: Efficiency(効率の良いコード)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_3/>Part 3: Efficiency</a><ul><li data-nav-id=/effective_kotlin/part_3/chapter_7/ title="Make it cheap" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_3/chapter_7/>Chapter 7 Make it cheap</a></li><li data-nav-id=/effective_kotlin/part_3/chapter_8/ title="Efficient collection processing" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_3/chapter_8/>Chapter 8: Efficient collection processing</a></li></ul></li></ul></li></ul><section id=footer><p>Built with <a href=https://github.com/matcornic/hugo-theme-learn><i class="fas fa-heart"></i></a> from <a href=https://getgrav.org>Grav</a> and <a href=https://gohugo.io/>Hugo</a></p></section></div></nav><section id=body><div id=overlay></div><div class="padding highlightable"><div><div id=top-bar><div id=breadcrumbs itemscope itemtype=http://data-vocabulary.org/Breadcrumb><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span>
<span id=toc-menu><i class="fas fa-list-alt"></i></span>
<span class=links><a href=https://mtakamur.github.io/>Pi fruit</a> > <a href=https://mtakamur.github.io/effective_kotlin/>忙しい人のための Effective Kotlin</a> > <a href=https://mtakamur.github.io/effective_kotlin/part_1/>Part 1: Good code(良いコードとは?)</a> > <a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/>Chapter 1: Safety(安全なコード)</a> > Item 1: Limit mutability(やたらと変更可能にしない)</span></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><ul><li><a href=#limiting-mutability-in-kotlin変更可能箇所を減らす>Limiting mutability in Kotlin(変更可能箇所を減らす)</a></li></ul></li></ul></nav></div></div></div></div><div id=head-tags></div><div id=body-inner><h1>Item 1: Limit mutability(やたらと変更可能にしない)</h1><p>更新日: 2021/12/11</p><h1 id=まとめ>まとめ</h1><hr><h1 id=ちょっと詳しく>ちょっと詳しく</h1><p>インスタンスの状態を表すために変数を使うことはよくあるでしょう。
Kotlin では <code>val</code> と <code>var</code> によって変数定義を行えます。
<code>val</code> で定義された物は一度値が代入されるともう変更できない(immutable な)変数となり、一方 <code>var</code> によって定義された変数は何度でも値を変更できます(mutable)。</p><p>これだけ見ると何でもかんでも <code>var</code> にしておいて、必要な時に自由に書き換えられた方が便利に見えます。
ただし、テーマである"安全性"の観点から見ると、 <code>var</code> を用いることによるデメリットも見えてきます。</p><ol><li>コードの理解とデバッグが難しくなります<ul><li><code>var</code> 変数はコードの実行により変更され得るポイントとなるので、その状態遷移を追いかけることは難しくなります</li></ul></li><li>コードの意味の推測が難しくなります<ul><li>immutable な値であれば、コードの中で変更されることのない状態となるので意味が明らかです</li><li>mutable な値は、いつ、何に、どんな理由で書き換えられるのかまで理解する必要が出てくるので、状態を追いかけるのが非常に難しくなります</li></ul></li><li>正しく排他処理を実装する必要があります<ul><li>色々なスレッドから値が変更され得るような状況では、同時に値を書き換えられないような実装(排他制御)が必要になります</li><li>もちろん、immutable な変数ではそんなこと考える必要ありません。</li></ul></li><li>状態の数だけ必要なテストが増えます<ul><li>値が変更されるということは、変更されるパターンの数だけ必要なテストが増加することを意味します</li><li>一般に必要なテストの量は、状態の数に対して指数関数的に増加してゆきます。変更可能な箇所は少ないほうが良いでしょう</li></ul></li><li>状態変化の通知が必要になる場合があります<ul><li>ある一つの mutable 変数を複数のクラスが参照しているような状況では、&ldquo;誰かが値を書き換えた"ということを他のクラスが知る必要がある場合があります</li></ul></li></ol><p>もちろん、全ての mutable な値がダメなわけではありません。
必要に応じて、正しく賢く mutable な値を使いましょう。</p><p>Kotlin の優れているところは、immutable で良い場合には簡単にそれが実現できるところです。
<code>val</code>にするだけ。</p><h3 id=limiting-mutability-in-kotlin変更可能箇所を減らす>Limiting mutability in Kotlin(変更可能箇所を減らす)</h3><p>Kotlin では、mutability、すなわち変更可能性を制限する仕組みが下記のようにいくつか用意されています。</p><ul><li><code>val</code>による変数宣言</li><li>読み取り専用コレクション</li><li>データクラスの copy()メソッド</li></ul><p>これらについてもうちょっと詳しく見て行きます。</p><h4 id=read-only-properties-valvalで定義される読み取り専用変数>Read-only properties <code>val</code>(<code>val</code>で定義される読み取り専用変数)</h4><p>すでに何度か登場していますが、Kotlin では<code>val</code>によって変数宣言することで、読み取り専用の変数を作ることができます。
ただちょっと注意しなければならないのは、<code>val</code>で宣言したからと言って必ずしも不変であったり、Java などでいう final を意味するわけではないということです。
例えば、後ほど登場しますが、mutable なコレクションを<code>val</code>で宣言しても、コレクションの要素の変更は問題なく行えてしまいます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> list = mutableListOf(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>) <span style=color:#75715e>// Mutable = 要素の変更が可能なコレクション
</span><span style=color:#75715e></span>list.add(<span style=color:#ae81ff>4</span>) <span style=color:#75715e>// 問題なし
</span></code></pre></div><p>上の例では、<code>val</code>で宣言したにもかかわらず要素の変更が行えています。これは、<code>val</code>が意味するのは<strong>参照先が不変</strong>ということだからです。
<code>val list</code>が表しているのは、どこのコレクションかという情報だけなので、参照先のコレクションにいくら変更が加えられたとしても<code>val list</code>としては知ったことではありません。
したがって、<code>val</code>による変数宣言で禁止されるのは下記のような変更です。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> list = mutableListOf(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
list = mutableListOf(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>) <span style=color:#75715e>// エラー！
</span></code></pre></div><p>上の例では、<code>val list</code>が指し示す先を、4, 5, 6 を要素とするまるっきり別のコレクションに変更しようとしているためエラーになります。</p><p>ここで紹介したルールを用いると、カスタム getter() も<code>val</code>変数として以下のような書き方ができることになります。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>var</span> firstName = <span style=color:#e6db74>&#34;Alice&#34;</span>
<span style=color:#66d9ef>var</span> familyName = <span style=color:#e6db74>&#34;Cern&#34;</span>

<span style=color:#66d9ef>val</span> fullName
   <span style=color:#66d9ef>get</span>() = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$firstName</span><span style=color:#e6db74> </span><span style=color:#e6db74>$familyName</span><span style=color:#e6db74>&#34;</span>

fum main() {
   println(fullName) <span style=color:#75715e>// Alice Cern
</span><span style=color:#75715e></span>   firstName = Atlas <span style=color:#75715e>// firstNameはmutableな変数なので書き換えてもよい
</span><span style=color:#75715e></span>   println(fullName) <span style=color:#75715e>// Atlas Cern
</span><span style=color:#75715e></span>}
</code></pre></div><p><code>fullName</code>は<code>val</code>変数なはずなのに中身が変わっていますね。
これは、<code>fullName</code>(のカスタム getter)はあくまで<code>firstName</code>と<code>familyName</code>から値を計算するということしか定義されていないので、<code>firstName</code>や<code>familyName</code>の中身がどう変更されようが気にしないということになります。</p><p>この動作からもう一つわかることとして、<strong>カスタム getter は呼び出されるたびに参照先の値を取得して都度計算して値を出力する</strong>ということです。
便利だからと言って、あまりに重い計算をカスタム getter に定義してしまうと、単に変数を読んでいるだけに見えるのに非常に反応が遅いということも起こり得ます。</p><p>というわけで、Kotlin における<code>val</code>プロパティは、不変である(=final である)ことを常には意味しないので注意が必要です。</p><h4 id=smart-castスマートキャスト--null-じゃないのはもう知ってるね->Smart cast(スマートキャスト -null じゃないのはもう知ってるね？-)</h4><p><code>val</code>の性質から、Kotlin では smart cast という仕組みが用意されています。
ここまでで触れられていませんが、<strong>Kotlin では基本的に変数は null にはなりません</strong>。
どうしても変数の状態として null が必要な場合には、<code>?</code>によって明示的にそれを示す必要があります。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> name : String? = <span style=color:#66d9ef>null</span> <span style=color:#75715e>// これは問題なし
</span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> name : String = <span style=color:#66d9ef>null</span> <span style=color:#75715e>// nullかもって言っていないのでこれはダメ
</span></code></pre></div><p>上記のように、null かも?という変数には、その型に<code>?</code>を加えます。
Kotlin では、null かもしれないクラス(?付)と絶対に null ではないクラスは別々の型と考えます。
null は便利かつ厄介な代物で、変数が null かも?(= nullable)な場合には、その取扱いはかなり気を使う必要があります(一般に null な値に対して演算はできませんで、何かしらの演算を試みた段階でいわゆる"ぬるぽ(NullPointerException)&ldquo;が発生してプログラムが継続できなくなります)。</p><p>nullable な値を扱うときは、多くの場合例外的な処理が必要となるので、null かどうかを都度チェックする必要があります。これが面倒くさいし、コードも汚くなるのであまりやりたくありません。
そこで、前置きが長くなりましたが、Kotlin では Smart cast という仕組みがあります。
簡単に表現すると、<strong>一度 null ではないと分かった<code>val</code>変数は、それ以降 non-null な値として扱える</strong>仕組みです。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> name: String = <span style=color:#e6db74>&#34;Alice&#34;</span>
<span style=color:#66d9ef>val</span> age : Int? = <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
   <span style=color:#66d9ef>if</span> (age <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>){
      println(<span style=color:#e6db74>&#34;Name = </span><span style=color:#e6db74>$name</span><span style=color:#e6db74>, age = </span><span style=color:#e6db74>$age</span><span style=color:#e6db74>&#34;</span>)
      <span style=color:#f92672>..</span>.
      <span style=color:#66d9ef>val</span> nextAge = age + <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 足し算なんかして大丈夫?
</span><span style=color:#75715e></span>      println(<span style=color:#e6db74>&#34;Name = </span><span style=color:#e6db74>$name</span><span style=color:#e6db74>, age = </span><span style=color:#e6db74>$age</span><span style=color:#e6db74>&#34;</span>)
   }
}
</code></pre></div><p>if 節の中身だけ読むと怖いことをやっていますね。
null かもしれない値に対する足し算です。
万が一<code>val age</code>が null だったら終わりです。
でもこの足し算が実行されている以上は絶対にそんなことはありません。if 節を実行する条件として、<code>val age</code>が null でないことを課しているからです。
したがって、人間が読めばすぐにわかることですが、if 節の中で<code>val age</code>が null ではあり得ないので、件の足し算は確実に安全に行えます。</p><p>一方、先ほどの例とほとんど同じに見える次の例では、例の足し算は絶対に確実に安全といえるでしょうか?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> name: String = <span style=color:#e6db74>&#34;Alice&#34;</span>
<span style=color:#66d9ef>var</span> age : Int? = <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
   <span style=color:#66d9ef>if</span> (age <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>){
      println(<span style=color:#e6db74>&#34;Name = </span><span style=color:#e6db74>$anme</span><span style=color:#e6db74>, age = </span><span style=color:#e6db74>$age</span><span style=color:#e6db74>&#34;</span>)
      <span style=color:#f92672>..</span>.
      <span style=color:#66d9ef>val</span> nextAge = age + <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 足し算なんかして大丈夫...じゃないこともある
</span><span style=color:#75715e></span>      println(<span style=color:#e6db74>&#34;Name = </span><span style=color:#e6db74>$name</span><span style=color:#e6db74>, age = </span><span style=color:#e6db74>$age</span><span style=color:#e6db74>&#34;</span>)
   }
}
</code></pre></div><p>これは安全とは言い切れません。なぜなら<code>var age</code>は変更されうるからです。もし<code>...</code>の部分の処理で<code>var age</code>が null に変更されていた場合は、この足し算はやってはいけません。</p><p>これらの例からわかるように、 <strong>Smart cast は<code>val</code>変数は変更されないという前提の下での仕組み</strong>です。
nullable な<code>var</code>変数に対しては Smart cast は機能しません(もちろんカスタム getter を備 f えた変数に対しても機能しない)。</p><p>簡単のために上記のような例を出しましたが、実際のコーディングで Smart cast の恩恵を受けるのは、変数をメソッドにパラメータとして与える場面が多いかと思います。
もしも Smart cast がないと、呼び出すメソッドが non-null なパラメータしか受け付けない場合には、呼び出しのたびに non-null な変数にキャストしてから渡すという、本質的な処理ではないコードを書く必要が出てきます。
Smart cast があるおかげで、コードをきれいに保つことができるわけです。</p><p>ちなみに Smart cast という名前ですが、一度 null でないことを確認した以降は<code>?</code>がとれた(non-null な)型とみなす、ある種の型変換を意味しています。</p><h4 id=separation-between-mutable-and-read-only-collections変更可能なコレクションと不可能なコレクション>Separation between mutable and read-only collections(変更可能なコレクションと不可能なコレクション)</h4><p>Kotlin では、要素の集合を上手に扱う手段としてコレクションが登場しています。
概念としては他言語での配列と同じです。</p><p>すでにこれまでの例で登場していますが、コレクション(list, set, map)にも mutable なものと immutable なものが別々に用意されています(相互の変換は一応可能)。
Kotlin のコレクションは immutable なものをベースにしており、mutable なコレクションがそれを継承して setter を実装しているイメージです。</p><p>Kotlin でコレクションを扱うとき、やってはいけないことがあります。
それは immutable -> mutable (不変コレクションからコレクションへの)ダウンキャストです。</p><ol><li>無理に書き換えると、そもそも immutable にした意味がない。チームで開発しているような状況では、&ldquo;このコレクションは immutable なはず"という前提が崩れるので、思わぬバグを生む原因になる。</li><li>mutable とみなされても、実際に書き換えが行えるかどうかはプラットフォームの実装による(後述)</li></ol><p>2 つめの理由についてもうちょっと詳しく説明します。例えば下記のコード例では実行結果はプラットフォームに依存します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> list = listOf(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)

<span style=color:#66d9ef>if</span> (list <span style=color:#66d9ef>is</span> MutableList){
   list.add(<span style=color:#ae81ff>4</span>) <span style=color:#75715e>// ここでエラーになるかどうかはプラットフォームに依る
</span><span style=color:#75715e></span>}
</code></pre></div><p>上記がエラーになる環境として、JVM 環境があります。JVM 環境では、<code>listOf</code>によって生成されるのは Java の<code>List</code>インターフェースを実装している<code>Arrays.ArrayList</code>になります(これは add などの要素変更メソッドを実装していないことに注意してください)。
しかし、<code>List</code>インターフェースには setter メソッド類も定義されているので、Kotlin の環境だと要素の編集機能も持っているとみなされて<code>MutableList</code>扱いになります。
したがって、実際には setter メソッド類の実装を持っていない<code>Arrays.ArrayList</code>に対して<code>add</code>が実行されることになってエラーになります。
<code>List</code>インターフェース</p><h4 id=copy-in-data-classes-データクラスのコピーメソッド>Copy in data classes (データクラスのコピーメソッド)</h4><p>Kotlin にはデータクラスという概念があります。
主にデータを(名前付きで)保持することを目的としたクラスですが、通常のクラス同様にメソッドを定義することもできます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>(
   <span style=color:#66d9ef>val</span> firstName : String,
   <span style=color:#66d9ef>val</span> familyName : String,
   <span style=color:#66d9ef>val</span> age : Int
) {
   <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getFullName</span>() = firstName + familyName
}
</code></pre></div><p>data class では、通常のクラスと比較して以下の違いがあります。</p><ul><li>equals(), hashCode()の自動実装</li><li>copy()メソッドの実装(以下で紹介します)</li></ul><p>上記の例では、人間一人に対して 1 インスタンスずつ生成するイメージでしょうか。
ところで、データクラスインスタンスを生成するときに、別のインスタンスの一部分のデータだけを変更すれば十分なことも頻繁にあります。
家族に対して子供を追加するときなどはその例だと思います(名前だけ違うけれども、苗字は一緒)。</p><p>このような場合、data class に備わっている copy()メソッドを使うことで、以下のように供インスタンスを作ることができます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> parent = Perosn(firstName = <span style=color:#e6db74>&#34;m&#34;</span>, familyName = <span style=color:#e6db74>&#34;t&#34;</span>, age = <span style=color:#ae81ff>27</span>)
<span style=color:#66d9ef>val</span> child = parent.copy(firstName = <span style=color:#e6db74>&#34;n&#34;</span>, age = <span style=color:#ae81ff>0</span>)
</code></pre></div><p>現実的にはちょっと気持ち悪い表現ではありますが、親をコピーして名前と年齢だけ変えて新しいインスタンスを作っています。</p><p>copy()メソッドがなぜこの節で登場するかというと、コピーの結果だけ見ると mutability の観点からはちょっと不思議なことが起きているからです。
コピーの結果を見ると、ひとまず parent のインスタンスのコピーを作ってしまって、firstName と age を書き換えたように見えないでしょうか?(プロパティはすべて<code>val</code>なのに!)</p><p>Person クラスのプロパティは全部<code>val</code>なのに変更できるのか？という疑問がわくかもしれませんが、copy()メソッド内での変更(しているように見える部分)は、あくまで新しいインスタンスの初期化処理の一部分です。
コピー元から変更する必要のないプロパティについては、コピー元からそのまま引き継ぐような動作をします。
したがって、内容をちょっと変更したコピーを作るために、プロパティを<code>var</code>にしたりする必要はないということになります。
プロパティを immutable に保ったままでこのような記述ができるので、とてもエレガントな手法ですね。</p><h4 id=different-kinds-of-mutation-pointsどこを可変にしようか>Different kinds of mutation points(どこを可変にしようか？)</h4><p>可変なコレクション(リスト)が必要になったとしましょう。
コレクションを変数化するときに、次の二つの書き方が思い浮かびます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> list1 = MutableList&lt;Int&gt; = mutableListOf() <span style=color:#75715e>// 1.コレクションがmutableで、変数自体はimmutable
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> list2 = List&lt;Int&gt; = listOf() <span style=color:#75715e>// 2.コレクションはimmutableで、変数自体がmutable
</span></code></pre></div><p>1.を使った場合、コレクション自体に要素を足し引きすることができます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>list1.add(<span style=color:#ae81ff>1</span>)
</code></pre></div><p>2.の場合、コレクションに add したりはできないので、要素を追加した新しいコレクションインスタンスで<code>list2</code>を置き換える操作が必要になります。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin>list2 = list2 + <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 元のlist2と1を合わせた新しいListで置き換える
</span></code></pre></div><p>この 2 つの例は、本文の言葉を借りれば mutation point (変更が生じうるポイント)が異なると言えます。 1.ではコレクション自体が mutation point、2. では変数そのものが mutation point になっています。
さて、どちらが優れているでしょうか？
読みやすさという意味では 1.だと思います。なぜならほとんど人間の言語だからです。</p><p>ただし、マルチスレッドでこのコレクションの変更を行う場合では 2.の方が安全(な実装を行いやすい)です。
マルチスレッド処理では、複数のスレッドから同時に同じコレクションが変更されることを想定せねばなりません。 1.によるコレクションの変更を行う場合、実際に要素を書き換える処理は MutableList に任せることになります。
いかなる時も MutableList が適切なタイミングで処理を行ってくれるという保証はないので、潜在的に危険です。
一方、2.の実装を行っている場合、<code>list2</code>変数の変更タイミングさえきちんと synchronized にしておけば、マルチスレッドからの同時変更による問題は起きないことになります。</p><p>もちろん、マルチスレッド処理においてどちらも安易な実装をすれば同時変更による問題を生じます。
実装 1.と 2.を比較したときに、mutation point が実装者側にある(=実装者が自由に制御できる)2.のパターンのほうが、安全な実装を行いやすいことになります。</p><p>蛇足ですが、もちろん次のような実装はやるべきではありません。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>var</span> list3 = MutableList&lt;Int&gt; = mutableListOf() <span style=color:#75715e>// コレクションの変更も変数の置き換えも両方できる
</span></code></pre></div><p>mutation point を無意味に増やすのは避けましょう。</p><h4 id=do-not-leak-mutation-points-mutation-point-は見えないように>Do not leak mutation points (mutation point は見えないように)</h4><p>Mutation point はよほどの理由がない限り、クラス外からは見えないようにするべきです。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Contacts</span>() {
   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> phoneNumbers = MutableList&lt;String&gt; = mutableListOf()

   <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getPhoneNumbers</span>() = phoneNumbers
}
</code></pre></div><p>上の例では、getPhoneNumbers()メソッドによって、登録されている電話番号のリストを取得できます。
それも mutable なリストとして。
ということで、getPhoneNumbers()が public である以上、誰でもいたずらで電話番号を書き換えることができてしまうわけです。
これは良くないですね。そもそも<code>phoneNumbers</code>を private にした意味がまるでありません。
対策としては、次の 2 点があげられます。</p><ol><li>外部に提供するデータを data class 化して、外部からの要求に対しては常に<code>copy()</code>メソッドの戻り値を渡す(defensive copy と呼ばれます)</li><li><code>getPhoneNumbers()</code>の戻り値の型を<code>List&lt;String></code>にアップキャストする</li></ol><h5 id=補足>補足</h5><p>Kotlin のコレクションは<code>copy()</code>メソッドを実装していません。
コレクションに対して defensive copy を行いたいときは、下記のようにコレクション変換関数を使うとシンプルです。</p><p>この例では、<code>List</code>から<code>List</code>への変換なので、型は変わっておらず一見意味のない変換に見えます。
ここでのポイントは、これらコレクション変換関数で生成されるのは新しいコレクションインスタンスであるということです。
つまり、同じ型への変換関数の使用は、data class でいうコピーに相当します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Contacts</span>() {
   <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> phoneNumbers = MutableList&lt;String&gt; = mutableListOf()

   <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>getPhoneNumbers</span>() = phoneNumbers.toList()
}
</code></pre></div><p>mutation point は外から直接見えないようにして、外部から好き勝手に変更を加えられないように注意しましょう。</p><footer class=footline></footer></div></div><div id=navigation><a class="nav nav-prev" href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/ title="Chapter 1: Safety(安全なコード)"><i class="fa fa-chevron-left"></i></a>
<a class="nav nav-next" href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_2_minimize_the_scope_of_variables/ title="Item 2: Minimize the scope of variables(変数のスコープは最小化する)" style=margin-right:0><i class="fa fa-chevron-right"></i></a></div></section><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=https://mtakamur.github.io/js/clipboard.min.js?1660402441></script><script src=https://mtakamur.github.io/js/perfect-scrollbar.min.js?1660402441></script><script src=https://mtakamur.github.io/js/perfect-scrollbar.jquery.min.js?1660402441></script><script src=https://mtakamur.github.io/js/jquery.sticky.js?1660402441></script><script src=https://mtakamur.github.io/js/featherlight.min.js?1660402441></script><script src=https://mtakamur.github.io/js/highlight.pack.js?1660402441></script><script>hljs.initHighlightingOnLoad()</script><script src=https://mtakamur.github.io/js/modernizr.custom-3.6.0.js?1660402441></script><script src=https://mtakamur.github.io/js/learn.js?1660402441></script><script src=https://mtakamur.github.io/js/hugo-learn.js?1660402441></script><script src=https://unpkg.com/mermaid@8.8.0/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></body></html>