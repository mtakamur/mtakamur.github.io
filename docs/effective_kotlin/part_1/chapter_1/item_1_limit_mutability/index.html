<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.85.0"><meta name=description content="Simple notes for software engineering"><meta name=author content="mtakamur"><link rel=icon href=https://mtakamur.github.io/images/favicon.png type=image/png><title>Item 1: Limit mutability(やたらと変更可能にしない) - Pi fruit</title><link href=https://mtakamur.github.io/css/nucleus.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/fontawesome-all.min.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/hybrid.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/featherlight.min.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/perfect-scrollbar.min.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/auto-complete.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/atom-one-dark-reasonable.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/theme.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/tabs.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/hugo-theme.css?1638636735 rel=stylesheet><link href=https://mtakamur.github.io/css/theme-blue.css?1638636735 rel=stylesheet><script src=https://mtakamur.github.io/js/jquery-3.3.1.min.js?1638636735></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}</style></head><body data-url=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_1_limit_mutability/><nav id=sidebar><div id=header-wrapper><div id=header><a id=logo href=https://mtakamur.github.io/><img src=https://mtakamur.github.io/images/logo-gray.svg><br>Pi Fruit</a></div><div class=searchbox><label for=search-by><i class="fas fa-search"></i></label>
<input data-search-input id=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script type=text/javascript src=https://mtakamur.github.io/js/lunr.min.js?1638636735></script><script type=text/javascript src=https://mtakamur.github.io/js/auto-complete.js?1638636735></script><script type=text/javascript>var baseurl="https://mtakamur.github.io/"</script><script type=text/javascript src=https://mtakamur.github.io/js/search.js?1638636735></script></div><section id=homelinks><ul><li><a class=padding href=https://mtakamur.github.io/><i class="fas fa-home"></i> Home</a></li></ul></section><div class=highlightable><ul class=topics><li data-nav-id=/kotlin/ title=Kotlin class=dd-item><a href=https://mtakamur.github.io/kotlin/>Kotlin</a><ul><li data-nav-id=/kotlin/struggled/ title=ハマったこと class=dd-item><a href=https://mtakamur.github.io/kotlin/struggled/>ハマったこと</a><ul><li data-nav-id=/kotlin/struggled/collection_deep_copy/ title="コレクションの deep copy が欲しい" class=dd-item><a href=https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/>コレクションの deep copy が欲しい</a></li><li data-nav-id=/kotlin/struggled/target_of_copy/ title="data class copy() の対象" class=dd-item><a href=https://mtakamur.github.io/kotlin/struggled/target_of_copy/>data class copy() の対象</a></li></ul></li><li data-nav-id=/kotlin/others/ title=その他 class=dd-item><a href=https://mtakamur.github.io/kotlin/others/>その他</a><ul><li data-nav-id=/kotlin/others/trailing_commas/ title="Trailing commas" class=dd-item><a href=https://mtakamur.github.io/kotlin/others/trailing_commas/>Trailing commas</a></li></ul></li></ul></li><li data-nav-id=/effective_kotlin/ title="忙しい人のための Effective Kotlin" class="dd-item
parent"><a href=https://mtakamur.github.io/effective_kotlin/>忙しい人のための Effective Kotlin</a><ul><li data-nav-id=/effective_kotlin/part_1/ title="Part 1: Good code(良いコードとは?)" class="dd-item
parent"><a href=https://mtakamur.github.io/effective_kotlin/part_1/>Part 1: Good code</a><ul><li data-nav-id=/effective_kotlin/part_1/chapter_1/ title="Chapter 1: Safety(安全なコード)" class="dd-item
parent"><a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/>Chapter 1: Safety</a><ul><li data-nav-id=/effective_kotlin/part_1/chapter_1/item_1_limit_mutability/ title="Item 1: Limit mutability(やたらと変更可能にしない)" class="dd-item active"><a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/item_1_limit_mutability/>Item 1: Limit mutability(やたらと変更可能にしない)</a></li></ul></li><li data-nav-id=/effective_kotlin/part_1/chapter_2/ title="Chapter 2: Readability(読みやすいコード)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_2/>Chapter 2: Readability</a></li></ul></li><li data-nav-id=/effective_kotlin/part_2/ title="Part 2: Code design(コード設計)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/>Part 2: Code design</a><ul><li data-nav-id=/effective_kotlin/part_2/chapter_3/ title="Chapter 3: Reusability(再利用性)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/>Chapter 3: Reusability</a><ul><li data-nav-id=/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/ title="Item 19: do not repeat knowledge" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/>Item 19: do not repeat knowledge</a></li></ul></li><li data-nav-id=/effective_kotlin/part_2/chapter_4/ title="Chapter 4: Abstraction design(抽象化設計)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_4/>Chapter 4: Abstraction design</a></li><li data-nav-id=/effective_kotlin/part_2/chapter_5/ title="Chapter 5: Object creation(インスタンス生成)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_5/>Chapter 5: Object creation</a></li><li data-nav-id=/effective_kotlin/part_2/chapter_6/ title="Chapter 6: Class design(クラス設計)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_2/chapter_6/>Chapter 6: Class design</a></li></ul></li><li data-nav-id=/effective_kotlin/part_3/ title="Part 3: Efficiency(効率の良いコード)" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_3/>Part 3: Efficiency</a><ul><li data-nav-id=/effective_kotlin/part_3/chapter_7/ title="Make it cheap" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_3/chapter_7/>Chapter 7 Make it cheap</a></li><li data-nav-id=/effective_kotlin/part_3/chapter_8/ title="Efficient collection processing" class=dd-item><a href=https://mtakamur.github.io/effective_kotlin/part_3/chapter_8/>Chapter 8: Efficient collection processing</a></li></ul></li></ul></li></ul><section id=footer><p>Built with <a href=https://github.com/matcornic/hugo-theme-learn><i class="fas fa-heart"></i></a> from <a href=https://getgrav.org>Grav</a> and <a href=https://gohugo.io/>Hugo</a></p></section></div></nav><section id=body><div id=overlay></div><div class="padding highlightable"><div><div id=top-bar><div id=breadcrumbs itemscope itemtype=http://data-vocabulary.org/Breadcrumb><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span>
<span id=toc-menu><i class="fas fa-list-alt"></i></span>
<span class=links><a href=https://mtakamur.github.io/>Pi fruit</a> > <a href=https://mtakamur.github.io/effective_kotlin/>忙しい人のための Effective Kotlin</a> > <a href=https://mtakamur.github.io/effective_kotlin/part_1/>Part 1: Good code(良いコードとは?)</a> > <a href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/>Chapter 1: Safety(安全なコード)</a> > Item 1: Limit mutability(やたらと変更可能にしない)</span></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><ul><li><a href=#limiting-mutability-in-kotlin変更可能箇所を減らす>Limiting mutability in Kotlin(変更可能箇所を減らす)</a></li></ul></li></ul></nav></div></div></div></div><div id=head-tags></div><div id=body-inner><h1>Item 1: Limit mutability(やたらと変更可能にしない)</h1><p>更新日: 2021/10/04</p><h1 id=まとめ>まとめ</h1><hr><h1 id=ちょっと詳しく>ちょっと詳しく</h1><p>インスタンスの状態を表すために変数を使うことはよくあるでしょう。
Kotlin では <code>val</code> と <code>var</code> によって変数定義を行えます。
<code>val</code> で定義された物は一度値が代入されるともう変更できない(immutable な)変数となり、一方 <code>var</code> によって定義された変数は何度でも値を変更できます(mutable)。</p><p>これだけ見ると何でもかんでも <code>var</code> にしておいて、必要な時に自由に書き換えられた方が便利に見えます。
ただし、テーマである"安全性"の観点から見ると、 <code>var</code> を用いることによるデメリットも見えてきます。</p><ol><li>コードの理解とデバッグが難しくなります<ul><li><code>var</code> 変数はコードの実行により変更され得るポイントとなるので、その状態遷移を追いかけることは難しくなります</li></ul></li><li>コードの意味の推測が難しくなります<ul><li>immutable な値であれば、コードの中で変更されることのない状態となるので意味が明らかです</li><li>mutable な値は、いつ、何に、どんな理由で書き換えられるのかまで理解する必要が出てくるので、状態を追いかけるのが非常に難しくなります</li></ul></li><li>正しく排他処理を実装する必要があります<ul><li>色々なスレッドから値が変更され得るような状況では、同時に値を書き換えられないような実装(排他制御)が必要になります</li><li>もちろん、immutable な変数ではそんなこと考える必要ありません。</li></ul></li><li>状態の数だけ必要なテストが増えます<ul><li>値が変更されるということは、変更されるパターンの数だけ必要なテストが増加することを意味します</li><li>一般に必要なテストの量は、状態の数に対して指数関数的に増加してゆきます。変更可能な箇所は少ないほうが良いでしょう</li></ul></li><li>状態変化の通知が必要になる場合があります<ul><li>ある一つの mutable 変数を複数のクラスが参照しているような状況では、&ldquo;誰かが値を書き換えた"ということを他のクラスが知る必要がある場合があります</li></ul></li></ol><p>もちろん、全ての mutable な値がダメなわけではありません。
必要に応じて、正しく賢く mutable な値を使いましょう。</p><p>Kotlin の優れているところは、immutable で良い場合には簡単にそれが実現できるところです。
<code>val</code>にするだけ。</p><h3 id=limiting-mutability-in-kotlin変更可能箇所を減らす>Limiting mutability in Kotlin(変更可能箇所を減らす)</h3><p>Kotlin では、mutability、すなわち変更可能性を制限する仕組みが下記のようにいくつか用意されています。</p><ul><li><code>val</code>による変数宣言</li><li>読み取り専用コレクション</li><li>データクラスの copy()メソッド</li></ul><p>これらについてもうちょっと詳しく見て行きます。</p><h4 id=read-only-properties-valvalで定義される読み取り専用変数>Read-only properties <code>val</code>(<code>val</code>で定義される読み取り専用変数)</h4><p>すでに何度か登場していますが、Kotlin では<code>val</code>によって変数宣言することで、読み取り専用の変数を作ることができます。
ただちょっと注意しなければならないのは、<code>val</code>で宣言したからと言って必ずしも不変であったり、Java などでいう final を意味するわけではないということです。
例えば、後ほど登場しますが、mutable なコレクションを<code>val</code>で宣言しても、コレクションの要素の変更は問題なく行えてしまいます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> list = mutableListOf(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>) <span style=color:#75715e>// Mutable = 要素の変更が可能なコレクション
</span><span style=color:#75715e></span>list.add(<span style=color:#ae81ff>4</span>) <span style=color:#75715e>// 問題なし
</span></code></pre></div><p>上の例では、<code>val</code>で宣言したにもかかわらず要素の変更が行えています。これは、<code>val</code>が意味するのは<strong>参照先が不変</strong>ということだからです。
<code>val list</code>が表しているのは、どこのコレクションかという情報だけなので、参照先のコレクションにいくら変更が加えられたとしても<code>val list</code>としては知ったことではありません。
したがって、<code>val</code>による変数宣言で禁止されるのは下記のような変更です。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> list = mutableListOf(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
list = mutableListOf(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>) <span style=color:#75715e>// エラー！
</span></code></pre></div><p>上の例では、<code>val list</code>が指し示す先を、4, 5, 6 を要素とするまるっきり別のコレクションに変更しようとしているためエラーになります。</p><p>ここで紹介したルールを用いると、カスタム getter() も<code>val</code>変数として以下のような書き方ができることになります。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>var</span> firstName = <span style=color:#e6db74>&#34;Alice&#34;</span>
<span style=color:#66d9ef>var</span> familyName = <span style=color:#e6db74>&#34;Cern&#34;</span>

<span style=color:#66d9ef>val</span> fullName
   <span style=color:#66d9ef>get</span>() = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$firstName</span><span style=color:#e6db74> </span><span style=color:#e6db74>$familyName</span><span style=color:#e6db74>&#34;</span>

fum main() {
   println(fullName) <span style=color:#75715e>// Alice Cern
</span><span style=color:#75715e></span>   firstName = Atlas <span style=color:#75715e>// firstNameはmutableな変数なので書き換えてもよい
</span><span style=color:#75715e></span>   println(fullName) <span style=color:#75715e>// Atlas Cern
</span><span style=color:#75715e></span>}
</code></pre></div><p><code>fullName</code>は<code>val</code>変数なはずなのに中身が変わっていますね。
これは、<code>fullName</code>(のカスタム getter)はあくまで<code>firstName</code>と<code>familyName</code>から値を計算するということしか定義されていないので、<code>firstName</code>や<code>familyName</code>の中身がどう変更されようが気にしないということになります。</p><p>この動作からもう一つわかることとして、<strong>カスタム getter は呼び出されるたびに参照先の値を取得して都度計算して値を出力する</strong>ということです。
便利だからと言って、あまりに重い計算をカスタム getter に定義してしまうと、単に変数を読んでいるだけに見えるのに非常に反応が遅いということも起こり得ます。</p><p>というわけで、Kotlin における<code>val</code>プロパティは、不変である(=final である)ことを常には意味しないので注意が必要です。</p><h4 id=smart-castスマートキャスト--null-じゃないのはもう知ってるね->Smart cast(スマートキャスト -null じゃないのはもう知ってるね？-)</h4><p><code>val</code>の性質から、Kotlin では smart cast という仕組みが用意されています。
ここまでで触れられていませんが、<strong>Kotlin では基本的に変数は null にはなりません</strong>。
どうしても変数の状態として null が必要な場合には、<code>?</code>によって明示的にそれを示す必要があります。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> name : String? = <span style=color:#66d9ef>null</span> <span style=color:#75715e>// これは問題なし
</span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> name : String = <span style=color:#66d9ef>null</span> <span style=color:#75715e>// nullかもって言っていないのでこれはダメ
</span></code></pre></div><p>上記のように、null かも?という変数には、その型に<code>?</code>を加えます。
Kotlin では、null かもしれないクラス(?付)と絶対に null ではないクラスは別々の型と考えます。
null は便利かつ厄介な代物で、変数が null かも?(= nullable)な場合には、その取扱いはかなり気を使う必要があります(一般に null な値に対して演算はできませんで、何かしらの演算を試みた段階でいわゆる"ぬるぽ(NullPointerException)&ldquo;が発生してプログラムが継続できなくなります)。</p><p>nullable な値を扱うときは、多くの場合例外的な処理が必要となるので、null かどうかを都度チェックする必要があります。これが面倒くさいし、コードも汚くなるのであまりやりたくありません。
そこで、前置きが長くなりましたが、Kotlin では Smart cast という仕組みがあります。
簡単に表現すると、<strong>一度 null ではないと分かった<code>val</code>変数は、それ以降 non-null な値として扱える</strong>仕組みです。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> name: String = <span style=color:#e6db74>&#34;Alice&#34;</span>
<span style=color:#66d9ef>val</span> age : Int? = <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
   <span style=color:#66d9ef>if</span> (age <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>){
      println(<span style=color:#e6db74>&#34;Name = </span><span style=color:#e6db74>$anme</span><span style=color:#e6db74>, age = </span><span style=color:#e6db74>$age</span><span style=color:#e6db74>&#34;</span>)
      <span style=color:#f92672>..</span>.
      <span style=color:#66d9ef>val</span> nextAge = age + <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 足し算なんかして大丈夫?
</span><span style=color:#75715e></span>      println(<span style=color:#e6db74>&#34;Name = </span><span style=color:#e6db74>$name</span><span style=color:#e6db74>, age = </span><span style=color:#e6db74>$age</span><span style=color:#e6db74>&#34;</span>)
   }
}
</code></pre></div><p>if 節の中身だけ読むと怖いことをやっていますね。
null かもしれない値に対する足し算です。
万が一<code>val age</code>が null だったら終わりです。
でもこの足し算が実行されている以上は絶対にそんなことはありません。if 節を実行する条件として、<code>val age</code>が null でないことを課しているからです。
したがって、人間が読めばすぐにわかることですが、if 節の中で<code>val age</code>が null ではあり得ないので、件の足し算は確実に安全に行えます。</p><p>一方、先ほどの例とほとんど同じに見える次の例では、例の足し算は絶対に確実に安全といえるでしょうか?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> name: String = <span style=color:#e6db74>&#34;Alice&#34;</span>
<span style=color:#66d9ef>var</span> age : Int? = <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
   <span style=color:#66d9ef>if</span> (age <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>){
      println(<span style=color:#e6db74>&#34;Name = </span><span style=color:#e6db74>$anme</span><span style=color:#e6db74>, age = </span><span style=color:#e6db74>$age</span><span style=color:#e6db74>&#34;</span>)
      <span style=color:#f92672>..</span>.
      <span style=color:#66d9ef>val</span> nextAge = age + <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 足し算なんかして大丈夫...じゃないこともある
</span><span style=color:#75715e></span>      println(<span style=color:#e6db74>&#34;Name = </span><span style=color:#e6db74>$name</span><span style=color:#e6db74>, age = </span><span style=color:#e6db74>$age</span><span style=color:#e6db74>&#34;</span>)
   }
}
</code></pre></div><p>これは安全とは言い切れません。なぜなら<code>var age</code>は変更されうるからです。もし<code>...</code>の部分の処理で<code>var age</code>が null に変更されていた場合は、この足し算はやってはいけません。</p><p>これらの例からわかるように、 <strong>Smart cast は<code>val</code>変数は変更されないという前提の下での仕組み</strong>です。
nullable な<code>var</code>変数に対しては Smart cast は機能しません(もちろんカスタム getter を備 f えた変数に対しても機能しない)。</p><p>簡単のために上記のような例を出しましたが、実際のコーディングで Smart cast の恩恵を受けるのは、変数をメソッドにパラメータとして与える場面が多いかと思います。
もしも Smart cast がないと、呼び出すメソッドが non-null なパラメータしか受け付けない場合には、呼び出しのたびに non-null な変数にキャストしてから渡すという、本質的な処理ではないコードを書く必要が出てきます。
Smart cast があるおかげで、コードをきれいに保つことができるわけです。</p><p>ちなみに Smart cast という名前ですが、一度 null でないことを確認した以降は<code>?</code>がとれた(non-null な)型とみなす、ある種の型変換を意味しています。</p><h4 id=separation-between-mutable-and-read-only-collections変更可能なコレクションと不可能なコレクション>Separation between mutable and read-only collections(変更可能なコレクションと不可能なコレクション)</h4><p>Kotlin では、要素の集合を上手に扱う手段としてコレクションが登場しています。
概念としては他言語での配列と同じです。</p><p>すでにこれまでの例で登場していますが、コレクション(list, set, map)にも mutable なものと immutable なものが別々に用意されています(相互の変換は一応可能)。
Kotlin のコレクションは immutable なものをベースにしており、mutable なコレクションがそれを継承して setter を実装しているイメージです。</p><p>Kotlin でコレクションを扱うとき、やってはいけないことがあります。
それは immutable -> mutable (不変コレクションからコレクションへの)ダウンキャストです。</p><ol><li>無理に書き換えると、そもそも immutable にした意味がない。チームで開発しているような状況では、&ldquo;このコレクションは immutable なはず"という前提が崩れるので、思わぬバグを生む原因になる。</li><li>mutable とみなされても、実際に書き換えが行えるかどうかはプラットフォームの実装による(後述)</li></ol><p>2 つめの理由についてもうちょっと詳しく説明します。例えば下記のコード例では実行結果はプラットフォームに依存します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>val</span> list = listOf(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)

<span style=color:#66d9ef>if</span> (list <span style=color:#66d9ef>is</span> MutableList){
   list.add(<span style=color:#ae81ff>4</span>) <span style=color:#75715e>// ここでエラーになるかどうかはプラットフォームに依る
</span><span style=color:#75715e></span>}
</code></pre></div><p>上記がエラーになる環境として、JVM 環境があります。JVM 環境では、<code>listOf</code>によって生成されるのは Java の<code>List</code>インターフェースを実装している<code>Arrays.ArrayList</code>になります(これは add などの要素変更メソッドを実装していないことに注意してください)。
しかし、<code>List</code>インターフェースには setter メソッド類も定義されているので、Kotlin の環境だと要素の編集機能も持っているとみなされて<code>MutableList</code>扱いになります。
したがって、実際には setter メソッド類の実装を持っていない<code>Arrays.ArrayList</code>に対して<code>add</code>が実行されることになってエラーになります。
<code>List</code>インターフェース</p><h4 id=copy-in-data-classes-データクラスのコピーメソッド>Copy in data classes (データクラスのコピーメソッド)</h4><footer class=footline></footer></div></div><div id=navigation><a class="nav nav-prev" href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_1/ title="Chapter 1: Safety(安全なコード)"><i class="fa fa-chevron-left"></i></a>
<a class="nav nav-next" href=https://mtakamur.github.io/effective_kotlin/part_1/chapter_2/ title="Chapter 2: Readability(読みやすいコード)" style=margin-right:0><i class="fa fa-chevron-right"></i></a></div></section><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=https://mtakamur.github.io/js/clipboard.min.js?1638636736></script><script src=https://mtakamur.github.io/js/perfect-scrollbar.min.js?1638636736></script><script src=https://mtakamur.github.io/js/perfect-scrollbar.jquery.min.js?1638636736></script><script src=https://mtakamur.github.io/js/jquery.sticky.js?1638636736></script><script src=https://mtakamur.github.io/js/featherlight.min.js?1638636736></script><script src=https://mtakamur.github.io/js/highlight.pack.js?1638636736></script><script>hljs.initHighlightingOnLoad()</script><script src=https://mtakamur.github.io/js/modernizr.custom-3.6.0.js?1638636736></script><script src=https://mtakamur.github.io/js/learn.js?1638636736></script><script src=https://mtakamur.github.io/js/hugo-learn.js?1638636736></script><script src=https://unpkg.com/mermaid@8.8.0/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></body></html>