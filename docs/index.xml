<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pi fruit</title>
    <link>https://mtakamur.github.io/</link>
    <description>Recent content on Pi fruit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 Oct 2021 11:34:05 +0900</lastBuildDate><atom:link href="https://mtakamur.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Item 19: do not repeat knowledge</title>
      <link>https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/</link>
      <pubDate>Sun, 31 Oct 2021 22:43:31 +0900</pubDate>
      
      <guid>https://mtakamur.github.io/effective_kotlin/part_2/chapter_3/item_19_do_not_repeat_knowledge/</guid>
      <description>更新日: 2021/10/04
この節の内容は、言語にとらわれず意識しておくべき基礎的な原則です。
まとめ  コーディングしている中で、コピペが必要になったときはちょっと立ち止まろう。同じことを二度書く必要はきっとないはず。 すべての変数やメソッドは変更されうる、という前提の下でコーディングしよう。 つまり無意味にコピペがあると、次の 2 つの理由で痛い目を見ます。  一つを変更したら全部変えなきゃ。面倒くさくない？ コピペしたところは一切もれなく(チームのほかの人がコピペしたものも含めて)把握している？たった一つでも見逃しているとその時点でバク発生！   ただし、何でもかんでも共通化してコピペを避けるべきというわけではない。共通化すべきかどうかの判断基準の一つは、片方を変更するときにもれなくもう片方も変更する必要があるか。 もしも別々に変更する可能性があるのであれば、それは共通化すべきでない。 なぜなら姿形はまったく同じでも意味の違うものであるから。 共通化にせよ分離にせよ、どちらかに極端に偏るといずれも良くない。 十分に訓練して、程よいバランスを保てるようにしよう。    ちょっと詳しく コーディングの原則としてよく知られている(しかし実践は実は難しい)&amp;ldquo;DRY (= Don&amp;rsquo;t Repeat Yourself) 原則&amp;quot;というものがあります。 平たく言えば、&amp;ldquo;同じ情報は 2 度書くのは良くないよ&amp;quot;という原則です。 まとめにある通り、1 つのプロジェクトの中でコピペをするということは、 どこかと同じ変数なりアルゴリズムなりを 2 度以上書いているということになります。 これは少なくとも下記の理由で避けるべきです。
 単純に無駄だから。共通で使えるようにすればコーディングする時間もファイルサイズも 2 つ分は必要ないはずですよね。 1 つを変更しなくてはいけない時に死ぬほど面倒くさい。 なぜならコピペしたものを全部もれなく変更しなくてはいけないから。 DRY 原則に反したコーディングを、WET(= We Enjoy Typing, Waste Everyone&amp;rsquo;s Time, or Write Everything Twice) アンチパターンと呼んだりします。 DRY に対して WET、いい感じで対になってますね。  Knowledge -情報/知識- この節で言う&amp;quot;Knowledge&amp;quot;としては主に下記の 2 つに焦点を当てています。
ロジック: コードの振る舞いを記述するもの 共通アルゴリズム: ロジックを実現するための下回り計算 上記 2 つの違いはぱっと見わかりづらいものですが、ロジックはアプリケーションの要求に応じていつでも変わりうるもので、 それに対してアルゴリズムは、ロジックが変更されても基本的には変更されることのない仕組みの部分をさしています。</description>
    </item>
    
    <item>
      <title>コレクションの deep copy が欲しい</title>
      <link>https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/</link>
      <pubDate>Sat, 30 Oct 2021 11:46:28 +0900</pubDate>
      
      <guid>https://mtakamur.github.io/kotlin/struggled/collection_deep_copy/</guid>
      <description>更新日: 2021/9/12
まとめ  toList, toSet, toMap などの、コレクションの変換メソッドで得られるのは&amp;quot;浅いコピー&amp;quot; (Shallow copy) コレクションそのものは変換元とは別インスタンスなるが、プリミティブ型以外の要素は参照のコピーなので、目的に合ったコピーになっているか注意が必要 data class の copy()メソッドによるコピーも、実際は shallow copy。プリミティブ型以外のプロパティについては元のインスタンスと同じ参照を持つ Kotlin 組み込みの実装だけによって deep copy を作ることは現状できない。クラスごとに deep copy 用のメソッドを自力で実装するのが単純。   インスタンスのコピー toList, toSet など、コレクションを変換、コピーすることができるメソッドが Kotlin には用意されています。この時、コレクションの要素も deep copy されると思い込んではまったお話。
値やインスタンスの集合であるコレクション(List, Set, Map など)を丸ごとコピーしたい場合は、下記のように toList, toSet, toMap など、目的の型への変換メソッドを使うことでコピーが行えます。 to~はコレクションの変換メソッドとして紹介されることが多いですが、変換元の型と同じ型への変換メソッドを使うと、中身が同じだけれども別インスタンスとしてのコレクション(コピー)を得ることができます。 ただし、プリミティブ型以外の要素は、 shallow copy が作られるだけで、参照先は変わりません。
下記を例にとってみます。 Person クラスを要素に持つ List を、 toList() メソッドによってコピーしています。生成されたコピーに対して、一つ目の要素の値を書き換えてみます。
data class Person( var name: String ) fun shallowCopy() { val family = listOf( Person(&amp;#34;a&amp;#34;), Person(&amp;#34;b&amp;#34;) ) val shallowCopiedFamily = family.</description>
    </item>
    
    <item>
      <title>data class copy() の対象</title>
      <link>https://mtakamur.github.io/kotlin/struggled/target_of_copy/</link>
      <pubDate>Sat, 30 Oct 2021 11:46:57 +0900</pubDate>
      
      <guid>https://mtakamur.github.io/kotlin/struggled/target_of_copy/</guid>
      <description>更新日: 2021/9/13
まとめ  data class のプロパティは、特に理由がない限りはプライマリコンストラクタ中で宣言したほうが良い プライマリコンストラクタ意外で定義したプロパティは、equals(), hashCode(), copy()メソッドの生成時に考慮されない   data class の copy()メソッドは primary constructor に基づく data class を作ると、Kotlin 側で自動的に下記の 5 つのメソッドを実装してくれ、私たちは特に気にしなくても便利にデータクラスを使えるのでした。
 equals(): プロパティの同一性を true / false の 2 値で返してくれるメソッド hashCode(): プロパティを基に一意なハッシュ値を生成してくれるメソッド toString(): インスタンスを文字列出力したときのフォーマット componentN(): N 番目のプロパティへのアクセサ copy(): 元のプロパティと同じ値を持った別のインスタンスを生成してくれるメソッド 今回は、copy() メソッドではいかなるプロパティも自動でコピーしてくれると思っていてハマったお話です。  結論として、copy() メソッドでコピーしてくれるのは data class の primary constructor で宣言されているプロパティのみです。データクラスの実装上、 コンストラクタ以外の部分でもプロパティを定義することができますが、それらは copy() メソッドの対象外になってしまうので注意が必要です。 このことは公式ドキュメントにも(分かりづらいですが)ちゃんと書いてありました。自動的に生成される 5 メソッドは、あくまでプライマリコンストラクタで宣言されたプロパティだけを対象として生成されるということですね。
例えば下記のような実装をすると、isAdult は data class Human のプロパティではありますが、 copy() メソッドで値がコピーされません。
data class Human( val name: String, val age: Int, ){ var isAdult: Boolean = false // コンストラクタ外での定義  } fun notCopied() { val human = Human(name = &amp;#34;mtakamur&amp;#34;, age = 27) if (human.</description>
    </item>
    
    <item>
      <title>Trailing commas</title>
      <link>https://mtakamur.github.io/kotlin/others/trailing_commas/</link>
      <pubDate>Sun, 31 Oct 2021 01:28:27 +0900</pubDate>
      
      <guid>https://mtakamur.github.io/kotlin/others/trailing_commas/</guid>
      <description>まとめ  Kotlin 1.4 以降ではコレクションやメソッド引数の最終要素に&amp;quot;,&amp;quot; (trailing comma) を残しておいてもコンパイルエラーになりません trailing comma があってもなくてもコードの動作は一切変わりません trailing comma をつけるようにしておくと、チーム開発するときのレビューがしやすくなります (コレクションやメソッドの引数に変更を加えても、追加削除した行だけが変更点として表示されるから)   Trailing comma (末尾のカンマ) コレクションの要素やメソッドのパラメータなど、同列の要素を複数個並べたいときは下記のようにカンマで区切って並べます。 この時、最後の要素の後には&amp;quot;,&amp;ldquo;を書かないのが一般的かと思います。 実際、Kotlin 1.4 より古いバージョンでは、余分なコンマを付けているとコンパイルエラーになります。
val colors = listOf( &amp;#34;red&amp;#34;, &amp;#34;green&amp;#34;, &amp;#34;blue&amp;#34; // &amp;lt;-ここにはカンマをつけていない  ) ところが Kotlin 1.4 以降では、最終要素の後ろにも&amp;rdquo;,&amp;ldquo;を残しておいて OK になりました。 この余分なカンマのことを trailing comma と呼びます。
なにがうれしい？ trailing comma があってもなくてもコードの動作には一切影響ありません。
trailing comma が若干ありがたく感じるのは、チームで開発を進めて、お互いにコードをレビューしあうような状況でしょうか。 開発を進めていくと、既存のメソッドにパラメータを追加したり、逆に削除したくなることはよくあるかと思いますが、この時に &amp;ldquo;これは最後の要素だからカンマを消して…&amp;rdquo; とか考える必要がなくなります。 カンマの追加/削除が本質的な変更点ではありえないでしょうから、余計な変更を加える必要がなくなり、コードレビューをするときも、本質的な変更点だけに集中することができるようになります。
配列やパラメータの順番だけを変更するときも幾分やりやすくなっているかと思います。 カンマのあるなしは気にせず、配列の行丸ごとの置換で OK になります。公式ドキュメントにもその旨記述があります。 多分ありがたいのはこれくらいでしょうか。
コンマ？カンマ？ 今さらコンマとカンマで表記ゆれがあることに気づきました…。 アドバイスとアドヴァイスみたいな。 カタカナで発音を表現しようとしている時点で間違ってますから、どっちでもいいですよね。</description>
    </item>
    
  </channel>
</rss>
